import {*} from "./option"

//FIXME64BIT
alias __size_t = Int<0, 4294967295>
alias u32 = Int<0, 4294967295>

const PAGE_SIZE: __size_t = 65536

//this is the pointer to the first available free address
//let memTop: __Ptr = (__memorySize() * PAGE_SIZE) as __Ptr

//this is the pointer to the last available free address
//let memBottom: __Ptr = (__memorySize() * PAGE_SIZE) as __Ptr


/*
  This is a version (aka dlmalloc) of malloc/free/realloc written by
  Doug Lea and released to the public domain, as explained at
  http://creativecommons.org/publicdomain/zero/1.0/ Send questions,
  comments, complaints, performance data, etc to dl@cs.oswego.edu

* This came from Version 2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea
  at ftp://gee.cs.oswego.edu/pub/misc/malloc.c

* I ported this partly as a test of WA1 (it was a good one and found 
  many bugs) and partly to have a production quality malloc. The 
  original uses many macros. I do not have macros, so I used 
  functions and consts. It will be slow, as a result.

* WA1 Preprocessor values:
WIN32: undefined
DLMALLOC_EXPORT: ???
MALLOC_ALIGNMENT: 8

MSPACES: 0
MSPACES                  default: 0 (false)
  If true, compile in support for independent allocation spaces.
  This is only supported if HAVE_MMAP is true.

ONLY_MSPACES: 0
ONLY_MSPACES             default: 0 (false)
  If true, only compile in mspace versions, not regular versions.

USE_LOCKS: 0
USE_LOCKS                default: 0 (false)
  Causes each call to each public routine to be surrounded with
  pthread or WIN32 mutex lock/unlock. (If set true, this can be
  overridden on a per-mspace basis for mspace versions.) If set to a
  non-zero value other than 1, locks are used, but their
  implementation is left out, so lock functions must be supplied manually,
  as described below.

USE_SPIN_LOCKS: 0
USE_RECURSIVE_LOCKS: 0
LOCK_AT_FORK: 0
FOOTERS: 0
FOOTERS                  default: 0
  If true, provide extra checking and dispatching by placing
  information in the footers of allocated chunks. This adds
  space and time overhead.

INSECURE: 0 (*)
INSECURE                 default: 0
  If true, omit checks for usage errors and heap space overwrites.

USE_DL_PREFIX: undefined
MALLOC_INSPECT_ALL: undefined
ABORT: __trap()

PROCEED_ON_ERROR: 0
PROCEED_ON_ERROR           default: defined as 0 (false)
  Controls whether detected bad addresses cause them to bypassed
  rather than aborting. If set, detected bad arguments to free and
  realloc are ignored. And all bookkeeping information is zeroed out
  upon a detected overwrite of freed heap space, thus losing the
  ability to ever return it from malloc again, but enabling the
  application to proceed. If PROCEED_ON_ERROR is defined, the
  static variable malloc_corruption_error_count is compiled in
  and can be examined to see if errors have occurred. This option
  generates slower code than the default abort policy.


DEBUG: undefined
ABORT_ON_ASSERT_FAILURE: 1
MALLOC_FAILURE_ACTION: no op
HAVE_MORECORE: 1
MORECORE: sbrk

MORECORE_CONTIGUOUS: 1
MORECORE_CONTIGUOUS       default: 1 (true) if HAVE_MORECORE
  If true, take advantage of fact that consecutive calls to MORECORE
  with positive arguments always return contiguous increasing
  addresses.  This is true of unix sbrk. It does not hurt too much to
  set it true anyway, since malloc copes with non-contiguities.
  Setting it false when definitely non-contiguous saves time
  and possibly wasted space it would take to discover this though.

MORECORE_CANNOT_TRIM: 1 (*)
MORECORE_CANNOT_TRIM      default: NOT defined
  True if MORECORE cannot release space back to the system when given
  negative arguments. This is generally necessary only if you are
  using a hand-crafted MORECORE function that cannot handle negative
  arguments.

NO_SEGMENT_TRAVERSAL: 0
NO_SEGMENT_TRAVERSAL       default: 0
  If non-zero, suppresses traversals of memory segments
  returned by either MORECORE or CALL_MMAP. This disables
  merging of segments that are contiguous, and selectively
  releasing them to the OS if unused, but bounds execution times.

HAVE_MMAP: 0
HAVE_MREMAP: 0
MMAP_CLEARS: 0
USE_BUILTIN_FFS: 1 (*)
malloc_getpagesize: 64KiB
USE_DEV_RANDOM: 0
NO_MALLINFO: 0 (*)
MALLINFO_FIELD_TYPE: __Ptr<0>
NO_MALLOC_STATS: 1 (*)
REALLOC_ZERO_BYTES_FREES: undefined
LACKS_*: ???
DEFAULT_GRANULARITY: 64KiB
DEFAULT_TRIM_THRESHOLD: 2M

DEFAULT_MMAP_THRESHOLD: ???
DEFAULT_MMAP_THRESHOLD       default: 256K
      Also settable using mallopt(M_MMAP_THRESHOLD, x)
  The request size threshold for using MMAP to directly service a
  request. Requests of at least this size that cannot be allocated
  using already-existing space will be serviced via mmap.  (If enough
  normal freed space already exists it is used instead.)  Using mmap
  segregates relatively large chunks of memory so that they can be
  individually obtained and released from the host system. A request
  serviced through mmap is never reused by any other request (at least
  not directly; the system may just so happen to remap successive
  requests to the same locations).  Segregating space in this way has
  the benefits that: Mmapped space can always be individually released
  back to the system, which helps keep the system level memory demands
  of a long-lived program low.  Also, mapped memory doesn't become
  `locked' between other chunks, as can happen with normally allocated
  chunks, which means that even trimming via malloc_trim would not
  release them.  However, it has the disadvantage that the space
  cannot be reclaimed, consolidated, and then used to service later
  requests, as happens with normal chunks.  The advantages of mmap
  nearly always outweigh disadvantages for "large" chunks, but the
  value of "large" may vary across systems.  The default is an
  empirically derived value that works well in most systems. You can
  disable mmap by setting to MAX_SIZE_T.


MAX_RELEASE_CHECK_RATE: MAX_SIZE_T (*)
*/

//FIXME64BIT
const MAX_SIZE_T: __size_t = 0xffffffff as __size_t;

__struct mallinfo {
    arena: __size_t;    /* non-mmapped space allocated from system */
    ordblks: __size_t;  /* number of free chunks */
    usmblks: __size_t;  /* maximum total allocated space */
    uordblks: __size_t; /* total allocated space */
    fordblks: __size_t; /* total free space */
    keepcost: __size_t; /* releasable (via malloc_trim) space */
}

/* The byte and bit size of a size_t */
//FIXME64BIT
const SIZE_T_SIZE: __size_t = 4;
const SIZE_T_BITSIZE: __size_t = 32;

/* Some constants coerced to size_t */
/* Annoying but necessary to avoid errors on some platforms */
//const SIZE_T_ZERO: __size_t =          0;
//const SIZE_T_ONE: __Ptr<0> =           1;
//const SIZE_T_TWO: __Ptr<0> =           2;
//const SIZE_T_FOUR: __Ptr<0> =          4;
const TWO_SIZE_T_SIZES: __size_t =        SIZE_T_SIZE * 2
//const FOUR_SIZE_T_SIZES: __Ptr<0> =    16;
//const SIX_SIZE_T_SIZES: __Ptr<0> =     24;
//FIXME64BIT
const HALF_MAX_SIZE_T: __size_t =         2147483647 

/* The bit mask value corresponding to MALLOC_ALIGNMENT */
//manually inlined - const CHUNK_ALIGN_MASK: __size_t = 7;

/* True if address a has acceptable alignment */
fn is_aligned(A: __Ptr) -> Bool (A & (7 as __Ptr)) == (0 as __Ptr);

/* the number of bytes to offset an address to align it */
//#define align_offset(A) ((((size_t)(A) & CHUNK_ALIGN_MASK) == 0)? 0 : ((MALLOC_ALIGNMENT - ((size_t)(A) & CHUNK_ALIGN_MASK)) & CHUNK_ALIGN_MASK))
fn align_offset(A: __Ptr) -> __Ptr if((A & (7 as __Ptr)) == (0 as __Ptr)) 0 as __Ptr; else (((8 as __Ptr) - (A & (7 as __Ptr))) & (7 as __Ptr));
fn align_offset_size_t(A: __size_t) -> __size_t if((A & 7) == 0) 0; else (8 - (A & 7)) & 7

/* MORECORE and MMAP must return MFAIL on failure */
//#define MFAIL                ((Void*)(MAX_SIZE_T))
//#define CMFAIL               ((char*)(MFAIL)) /* defined for convenience */
const CMFAIL: __Ptr = MAX_SIZE_T as __Ptr

//#define CALL_MORECORE(S)    MORECORE_DEFAULT(S)

/* MMAP stuff, all stubbed out */
//#define USE_MMAP_BIT            (SIZE_T_ZERO)
//#define MMAP(s)                 MFAIL
//#define MUNMAP(a, s)            (-1)
//#define DIRECT_MMAP(s)          MFAIL
//#define CALL_DIRECT_MMAP(s)     DIRECT_MMAP(s)
//#define CALL_MMAP(s)            MMAP(s)
//#define CALL_MUNMAP(a, s)       MUNMAP((a), (s))
//#define CALL_MREMAP(addr, osz, nsz, mv)     MFAIL

/* mstate bit set if continguous morecore disabled or failed */
//#define USE_NONCONTIGUOUS_BIT (4U)

/* segment bit set in create_mspace_with_base */
//#define EXTERN_BIT            (8U)

/* LOCK stuff, all stubbed out */
//#define USE_LOCK_BIT               (0U)
//#define INITIAL_LOCK(l)            (0)
//#define DESTROY_LOCK(l)            (0)
//#define ACQUIRE_MALLOC_GLOBAL_LOCK()
//#define RELEASE_MALLOC_GLOBAL_LOCK()

/* -----------------------  Chunk representations ------------------------ */

/*
  (The following includes lightly edited explanations by Colin Plumb.)

  The malloc_chunk declaration below is misleading (but accurate and
  necessary).  It declares a "view" into memory allowing access to
  necessary fields at known offsets from a given base.

  Chunks of memory are maintained using a `boundary tag' method as
  originally described by Knuth.  (See the paper by Paul Wilson
  ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a survey of such
  techniques.)  Sizes of free chunks are stored both in the front of
  each chunk and at the end.  This makes consolidating fragmented
  chunks into bigger chunks fast.  The head fields also hold bits
  representing whether chunks are free or in use.

  Here are some pictures to make it clearer.  They are "exploded" to
  show that the state of a chunk can be thought of as extending from
  the high 31 bits of the head field of its header through the
  prev_foot and PINUSE_BIT bit of the following chunk header.

  A chunk that's in use looks like:

   chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           | Size of previous chunk (if P = 0)                             |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         1| +-+
   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               |
         +-                                                             -+
         |                                                               |
         +-                                                             -+
         |                                                               :
         +-      size - sizeof(size_t) available payload bytes          -+
         :                                                               |
 chunk-> +-                                                             -+
         |                                                               |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|
       | Size of next chunk (may or may not be in use)               | +-+
 mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    And if it's free, it looks like this:

   chunk-> +-                                                             -+
           | User payload (must be in use, or we would have merged!)       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         0| +-+
   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Next pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Prev pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               :
         +-      size - sizeof(struct chunk) unused bytes               -+
         :                                                               |
 chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Size of this chunk                                            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|
       | Size of next chunk (must be in use, or we would have merged)| +-+
 mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                                                               :
       +- User payload                                                -+
       :                                                               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                                                     |0|
                                                                     +-+
  Note that since we always merge adjacent free chunks, the chunks
  adjacent to a free chunk must be in use.

  Given a pointer to a chunk (which can be derived trivially from the
  payload pointer) we can, in O(1) time, find out whether the adjacent
  chunks are free, and if so, unlink them from the lists that they
  are on and merge them with the current chunk.

  Chunks always begin on even word boundaries, so the mem portion
  (which is returned to the user) is also on an even word boundary, and
  thus at least double-word aligned.

  The P (PINUSE_BIT) bit, stored in the unused low-order bit of the
  chunk size (which is always a multiple of two words), is an in-use
  bit for the *previous* chunk.  If that bit is *clear*, then the
  word before the current chunk size contains the previous chunk
  size, and can be used to find the front of the previous chunk.
  The very first chunk allocated always has this bit set, preventing
  access to non-existent (or non-owned) memory. If pinuse is set for
  any given chunk, then you CANNOT determine the size of the
  previous chunk, and might even get a memory addressing fault when
  trying to do so.

  The C (CINUSE_BIT) bit, stored in the unused second-lowest bit of
  the chunk size redundantly records whether the current chunk is
  inuse (unless the chunk is mmapped). This redundancy enables usage
  checks within free and realloc, and reduces indirection when freeing
  and consolidating chunks.

  Each freshly allocated chunk must have both cinuse and pinuse set.
  That is, each allocated chunk borders either a previously allocated
  and still in-use chunk, or the base of its memory arena. This is
  ensured by making all allocations from the `lowest' part of any
  found chunk.  Further, no free chunk physically borders another one,
  so each free chunk is known to be preceded and followed by either
  inuse chunks or the ends of memory.

  Note that the `foot' of the current chunk is actually represented
  as the prev_foot of the NEXT chunk. This makes it easier to
  deal with alignments etc but can be very confusing when trying
  to extend or adapt this code.

  The exceptions to all this are

     1. The special chunk `top' is the top-most available chunk (i.e.,
        the one bordering the end of available memory). It is treated
        specially.  Top is never included in any bin, is used only if
        no other chunk is available, and is released back to the
        system if it is very large (see M_TRIM_THRESHOLD).  In effect,
        the top chunk is treated as larger (and thus less well
        fitting) than any other available chunk.  The top chunk
        doesn't update its trailing size field since there is no next
        contiguous chunk that would have to index off it. However,
        space is still allocated for it (TOP_FOOT_SIZE) to enable
        separation or merging when space is extended.

     3. Chunks allocated via mmap, have both cinuse and pinuse bits
        cleared in their head fields.  Because they are allocated
        one-by-one, each must carry its own prev_foot field, which is
        also used to hold the offset this chunk has within its mmapped
        region, which is needed to preserve alignment. Each mmapped
        chunk is trailed by the first two fields of a fake next-chunk
        for sake of usage checks.

*/

__struct malloc_chunk {
  prev_foot: __size_t;  // Size of previous chunk (if free)
  head: __size_t;       // Size and inuse bits
  fd: malloc_chunk;         // double links -- used only if free. was struct malloc_chunk*
  bk: malloc_chunk;
}

/*
typedef struct malloc_chunk  mchunk;
typedef struct malloc_chunk* mchunkptr;
typedef struct malloc_chunk* sbinptr;  // The type of bins of chunks
typedef unsigned int bindex_t;         // using a __size_t because I don't have a u32
typedef unsigned int binmap_t;         // Described below 
typedef unsigned int flag_t;           // The type of various bit flag sets
*/

const MCHUNK_SIZE: __size_t         = __sizeof(malloc_chunk);
//#define CHUNK_OVERHEAD      (SIZE_T_SIZE) = 4
const CHUNK_OVERHEAD: __size_t = SIZE_T_SIZE

/* The smallest size we can malloc is an aligned minimal chunk */
//#define MIN_CHUNK_SIZE ((MCHUNK_SIZE + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)
const MIN_CHUNK_SIZE: __size_t = (MCHUNK_SIZE + 7) & ~(7 as __size_t)

/* conversion from malloc headers to user pointers, and back */
//#define chunk2mem(p)        ((Void*)((char*)(p)       + TWO_SIZE_T_SIZES))
fn chunk2mem(p: malloc_chunk) -> __Ptr (p as __Ptr) + (TWO_SIZE_T_SIZES as __Ptr)
fn chunk2memPtr(p: __Ptr) -> __Ptr p + (TWO_SIZE_T_SIZES as __Ptr)
//#define mem2chunk(mem)      ((mchunkptr)((char*)(mem) - TWO_SIZE_T_SIZES))
fn mem2chunk(mem: __Ptr) -> malloc_chunk (mem - (TWO_SIZE_T_SIZES as __Ptr)) as malloc_chunk

/* chunk associated with aligned address A */
//#define align_as_chunk(A)   (mchunkptr)((A) + align_offset(chunk2mem(A)))
fn align_as_chunk(A: __Ptr) -> malloc_chunk  (A + align_offset(chunk2memPtr(A))) as malloc_chunk

/* Bounds on request (not chunk) sizes. */
/* WA1 - I kinda hard coded this based on what I know of JS. We will blow up before this anyway FIXME64BIT*/
const MAX_REQUEST  = 1073741824 as __size_t;
//#define MIN_REQUEST         (MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)
const MIN_REQUEST  = (MIN_CHUNK_SIZE - CHUNK_OVERHEAD - 1);

/* pad request bytes into a usable size */
//#define pad_request(req) (((req) + CHUNK_OVERHEAD + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)
fn pad_request(req: __size_t) -> __size_t   (req + CHUNK_OVERHEAD + 7) & ~(7 as __size_t)

/* pad request, checking for minimum (but not maximum) */
fn request2size(req: __size_t) -> __size_t if(req < MIN_REQUEST) MIN_CHUNK_SIZE; else pad_request(req);

/* ------------------ Operations on head and foot fields ----------------- */

/*
  The head field of a chunk is or'ed with PINUSE_BIT when previous
  adjacent chunk in use, and or'ed with CINUSE_BIT if this chunk is in
  use, unless mmapped, in which case both bits are cleared.

  FLAG4_BIT is not used by this malloc, but might be useful in extensions.
*/

//#define PINUSE_BIT          (SIZE_T_ONE) //1
//#define CINUSE_BIT          (SIZE_T_TWO) //2
//#define FLAG4_BIT           (SIZE_T_FOUR) //4
//#define INUSE_BITS          (PINUSE_BIT|CINUSE_BIT) //3
//#define FLAG_BITS           (PINUSE_BIT|CINUSE_BIT|FLAG4_BIT) //7

/* Head value for fenceposts */
//#define FENCEPOST_HEAD      (INUSE_BITS|SIZE_T_SIZE) //7
const FENCEPOST_HEAD: __size_t      = 3|SIZE_T_SIZE

/* extraction of fields from head words */
/* WA1 - better get these guys inlined! */
//#define cinuse(p)           ((p)->head & CINUSE_BIT)
fn cinuse(p: malloc_chunk) -> Bool           (p.head & (2 as __size_t)) != 0;
//#define pinuse(p)           ((p)->head & PINUSE_BIT)
fn pinuse(p: malloc_chunk) -> Bool           (p.head & (1 as __size_t)) != 0;
//#define flag4inuse(p)       ((p)->head & FLAG4_BIT)
fn flag4inuse(p: malloc_chunk) -> Bool       (p.head & (4 as __size_t)) != 0;
//#define is_inuse(p)         (((p)->head & INUSE_BITS) != PINUSE_BIT)
fn is_inuse(p: malloc_chunk) -> Bool         (p.head & (3 as __size_t)) != (1 as __size_t);
//#define is_mmapped(p)       (((p)->head & INUSE_BITS) == 0)

//#define chunksize(p)        ((p)->head & ~(FLAG_BITS))
fn chunksize(p: malloc_chunk) -> __size_t        (p.head & ~(7 as __size_t))

//#define clear_pinuse(p)     ((p)->head &= ~PINUSE_BIT)
fn clear_pinuse(p: malloc_chunk) -> Void     p.head &= ~(1 as __size_t)
//#define set_flag4(p)        ((p)->head |= FLAG4_BIT)
fn set_flag4(p: malloc_chunk) -> Void        p.head |= (4 as __size_t)
//#define clear_flag4(p)      ((p)->head &= ~FLAG4_BIT)
fn clear_flag4(p: malloc_chunk) -> Void      p.head &= ~(4 as __size_t)

/* Treat space at ptr +/- offset as a chunk */
/* WA1 - and this, children, is why our typesystem has a back door and an unsafe feature */
//#define chunk_plus_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))
fn chunk_plus_offset(p: malloc_chunk, s: __size_t) -> malloc_chunk  ((p as __Ptr) + (s as __Ptr)) as malloc_chunk
//#define chunk_minus_offset(p, s) ((mchunkptr)(((char*)(p)) - (s)))
fn chunk_minus_offset(p: malloc_chunk, s: __size_t) -> malloc_chunk ((p as __Ptr) - (s as __Ptr)) as malloc_chunk

/* Ptr to next or previous physical malloc_chunk. */
//#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~FLAG_BITS)))
fn next_chunk(p: malloc_chunk) -> malloc_chunk ((p as __Ptr) + ((p.head & ~(7 as __size_t)) as __Ptr)) as malloc_chunk
//#define prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)->prev_foot) ))
fn prev_chunk(p: malloc_chunk) -> malloc_chunk ((p as __Ptr) - (p.prev_foot as __Ptr)) as malloc_chunk

/* extract next chunk's pinuse bit */
//#define next_pinuse(p)  ((next_chunk(p)->head) & PINUSE_BIT)
fn next_pinuse(p: malloc_chunk) -> Bool (next_chunk(p).head & (1 as __size_t)) != 0

/* Get/set size at footer */
//#define get_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot)
//#define set_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot = (s))
fn set_foot(p: malloc_chunk, s: __size_t) -> Void { 
    // you need a temporary because the '+' operator can't be used as an lhs. 
    let t = ((p as __Ptr) + (s as __Ptr)) as malloc_chunk
    t.prev_foot = s
}

/* Set size, pinuse bit, and foot */
//#define set_size_and_pinuse_of_free_chunk(p, s)  ((p)->head = (s|PINUSE_BIT), set_foot(p, s))
fn set_size_and_pinuse_of_free_chunk(p: malloc_chunk, s: __size_t) -> Void {
    p.head = (s|(1 as __size_t));
    set_foot(p, s);
}

/* Set size, pinuse bit, foot, and clear next pinuse */
//#define set_free_with_pinuse(p, s, n)  (clear_pinuse(n), set_size_and_pinuse_of_free_chunk(p, s))
fn set_free_with_pinuse(p: malloc_chunk, s: __size_t, n: malloc_chunk) -> Void {
    clear_pinuse(n);
    set_size_and_pinuse_of_free_chunk(p, s);
}

/* Get the internal overhead associated with chunk p */
//#define overhead_for(p) (is_mmapped(p)? MMAP_CHUNK_OVERHEAD : CHUNK_OVERHEAD)
//fn overhead_for(p: malloc_chunk) -> __size_t 4;

/* Return true if malloced space is not necessarily cleared */
//#define calloc_must_clear(p) (1)
//fn calloc_must_clear(p: malloc_chunk) -> Bool true;

/* ---------------------- Overlaid data structures ----------------------- */

/*
  When chunks are not in use, they are treated as nodes of either
  lists or trees.

  "Small"  chunks are stored in circular doubly-linked lists, and look
  like this:

    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk                            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                         |P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  Larger chunks are kept in a form of bitwise digital trees (aka
  tries) keyed on chunksizes.  Because malloc_tree_chunks are only for
  free chunks greater than 256 bytes, their size doesn't impose any
  constraints on user chunk sizes.  Each node looks like:

    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk                            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                         |P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk of same size        |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk of same size       |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to left child (child[0])                  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to right child (child[1])                 |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to parent                                 |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             bin index of this chunk                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space                                      .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  Each tree holding treenodes is a tree of unique chunk sizes.  Chunks
  of the same size are arranged in a circularly-linked list, with only
  the oldest chunk (the next to be used, in our FIFO ordering)
  actually in the tree.  (Tree members are distinguished by a non-null
  parent pointer.)  If a chunk with the same size an an existing node
  is inserted, it is linked off the existing node using pointers that
  work in the same way as fd/bk pointers of small chunks.

  Each tree contains a power of 2 sized range of chunk sizes (the
  smallest is 0x100 <= x < 0x180), which is is divided in half at each
  tree level, with the chunks in the smaller half of the range (0x100
  <= x < 0x140 for the top nose) in the left subtree and the larger
  half (0x140 <= x < 0x180) in the right subtree.  This is, of course,
  done by inspecting individual bits.

  Using these rules, each node's left subtree contains all smaller
  sizes than its right subtree.  However, the node at the root of each
  subtree has no particular ordering relationship to either.  (The
  dividing line between the subtree sizes is based on trie relation.)
  If we remove the last chunk of a given size from the interior of the
  tree, we need to replace it with a leaf node.  The tree ordering
  rules permit a node to be replaced by any leaf below it.

  The smallest chunk in a tree (a common operation in a best-fit
  allocator) can be found by walking a path to the leftmost leaf in
  the tree.  Unlike a usual binary tree, where we follow left child
  pointers until we reach a null, here we follow the right child
  pointer any time the left one is null, until we reach a leaf with
  both child pointers null. The smallest chunk in the tree will be
  somewhere along that path.

  The worst case number of steps to add, find, or remove a node is
  bounded by the number of bits differentiating chunks within
  bins. Under current bin calculations, this ranges from 6 up to 21
  (for 32 bit sizes) or up to 53 (for 64 bit sizes). The typical case
  is of course much better.
*/

__struct malloc_tree_chunk {
  /* The first four fields must be compatible with malloc_chunk */
  prev_foot: __size_t;
  head: __size_t;
  fd: malloc_tree_chunk;
  bk: malloc_tree_chunk;

  //WA1 - in dlmalloc these are an array of size 2. I don't have an 
  //inline array implementation, and it doesn't seem that important
  child_0: __Option<malloc_tree_chunk>; 
  child_1: __Option<malloc_tree_chunk>;
  parent: __Option<malloc_tree_chunk>;
  index: u32;
}

/* A little helper macro for trees */
//#define leftmost_child(t) ((t)->child[0] != 0? (t)->child[0] : (t)->child[1])
fn leftmost_child(t: malloc_tree_chunk) -> __Option<malloc_tree_chunk> {
  if(t.child_0.isSome())
    t.child_0;
  else 
    t.child_1;
}

fn tree_chunksize(p: malloc_tree_chunk) -> __size_t        (p.head & ~(7 as __size_t));
fn tree_chunk_plus_offset(p: malloc_tree_chunk, s: __size_t) -> malloc_tree_chunk  ((p as __Ptr) + (s as __Ptr)) as malloc_tree_chunk
fn tree_set_foot(p: malloc_tree_chunk, s: __size_t) -> Void { 
    // you need a temporary because the '+' operator can't be used as an lhs. 
    let t = ((p as __Ptr) + (s as __Ptr)) as malloc_chunk
    t.prev_foot = s
}
fn tree_set_size_and_pinuse_of_free_chunk(p: malloc_tree_chunk, s: __size_t) -> Void {
    p.head = (s|(1 as __size_t));
    tree_set_foot(p, s);
}
fn tree_chunk2mem(p: malloc_tree_chunk) -> __Ptr (p as __Ptr) + (TWO_SIZE_T_SIZES as __Ptr)

/* ----------------------------- Segments -------------------------------- */

/*
  Each malloc space may include non-contiguous segments, held in a
  list headed by an embedded malloc_segment record representing the
  top-most space. Segments also include flags holding properties of
  the space. Large chunks that are directly allocated by mmap are not
  included in this list. They are instead independently created and
  destroyed without otherwise keeping track of them.

  Segment management mainly comes into play for spaces allocated by
  MMAP.  Any call to MMAP might or might not return memory that is
  adjacent to an existing segment.  MORECORE normally contiguously
  extends the current space, so this space is almost always adjacent,
  which is simpler and faster to deal with. (This is why MORECORE is
  used preferentially to MMAP when both are available -- see
  sys_alloc.)  When allocating using MMAP, we don't use any of the
  hinting mechanisms (inconsistently) supported in various
  implementations of unix mmap, or distinguish reserving from
  committing memory. Instead, we just ask for space, and exploit
  contiguity when we get it.  It is probably possible to do
  better than this on some systems, but no general scheme seems
  to be significantly better.

  Management entails a simpler variant of the consolidation scheme
  used for chunks to reduce fragmentation -- new adjacent memory is
  normally prepended or appended to an existing segment. However,
  there are limitations compared to chunk consolidation that mostly
  reflect the fact that segment processing is relatively infrequent
  (occurring only when getting memory from system) and that we
  don't expect to have huge numbers of segments:

  * Segments are not indexed, so traversal requires linear scans.  (It
    would be possible to index these, but is not worth the extra
    overhead and complexity for most programs on most platforms.)
  * New segments are only appended to old ones when holding top-most
    memory; if they cannot be prepended to others, they are held in
    different segments.

  Except for the top-most segment of an mstate, each segment record
  is kept at the tail of its segment. Segments are added by pushing
  segment records onto the list headed by &mstate.seg for the
  containing mstate.

  Segment flags control allocation/merge/deallocation policies:
  * If EXTERN_BIT set, then we did not allocate this segment,
    and so should not try to deallocate or merge with others.
    (This currently holds only for the initial segment passed
    into create_mspace_with_base.)
  * If USE_MMAP_BIT set, the segment may be merged with
    other surrounding mmapped segments and trimmed/de-allocated
    using munmap.
  * If neither bit is set, then the segment was obtained using
    MORECORE so can be merged with surrounding MORECORE'd segments
    and deallocated/trimmed using MORECORE with negative arguments.
*/

__struct malloc_segment {
  base: __Ptr;                    /* base address */
  size: __size_t;                 /* allocated size */
  next: __Option<malloc_segment>;   /* ptr to next segment */
  //sflags: u32;             /* mmap and extern flag WA1 - was a u32, but not used*/
}

//#define is_mmapped_segment(S)  ((S)->sflags & USE_MMAP_BIT) - false
//#define is_extern_segment(S)   ((S)->sflags & EXTERN_BIT) - false

/* ---------------------------- malloc_state ----------------------------- */

/*
   A malloc_state holds all of the bookkeeping for a space.
   The main fields are:

  Top
    The topmost chunk of the currently active segment. Its size is
    cached in topsize.  The actual size of topmost space is
    topsize+TOP_FOOT_SIZE, which includes space reserved for adding
    fenceposts and segment records if necessary when getting more
    space from the system.  The size at which to autotrim top is
    cached from mparams in trim_check, except that it is disabled if
    an autotrim fails.

  Designated victim (dv)
    This is the preferred chunk for servicing small requests that
    don't have exact fits.  It is normally the chunk split off most
    recently to service another small request.  Its size is cached in
    dvsize. The link fields of this chunk are not maintained since it
    is not kept in a bin.

  SmallBins
    An array of bin headers for free chunks.  These bins hold chunks
    with sizes less than MIN_LARGE_SIZE bytes. Each bin contains
    chunks of all the same size, spaced 8 bytes apart.  To simplify
    use in double-linked lists, each bin header acts as a malloc_chunk
    pointing to the real first node, if it exists (else pointing to
    itself).  This aVoids special-casing for headers.  But to aVoid
    waste, we allocate only the fd/bk pointers of bins, and then use
    repositioning tricks to treat these as the fields of a chunk.
    *_* note - we don't use this trick right now.

  TreeBins
    Treebins are pointers to the roots of trees holding a range of
    sizes. There are 2 equally spaced treebins for each power of two
    from TREE_SHIFT to TREE_SHIFT+16. The last bin holds anything
    larger.

  Bin maps
    There is one bit map for small bins ("smallmap") and one for
    treebins ("treemap).  Each bin sets its bit when non-empty, and
    clears the bit when empty.  Bit operations are then used to aVoid
    bin-by-bin searching -- nearly all "search" is done without ever
    looking at bins that won't be selected.  The bit maps
    conservatively use 32 bits per map word, even if on 64bit system.
    For a good description of some of the bit-based techniques used
    here, see Henry S. Warren Jr's book "Hacker's Delight" (and
    supplement at http://hackersdelight.org/). Many of these are
    intended to reduce the branchiness of paths through malloc etc, as
    well as to reduce the number of memory locations read or written.

  Segments
    A list of segments headed by an embedded malloc_segment record
    representing the initial space.

  Address check support
    The least_addr field is the least address ever obtained from
    MORECORE or MMAP. Attempted frees and reallocs of any address less
    than this are trapped (unless INSECURE is defined).

  Magic tag
    A cross-check field that should always hold same value as mparams.magic.

  Max allowed footprint
    The maximum allowed bytes to allocate from system (zero means no limit)

  Flags
    Bits recording whether to use MMAP, locks, or contiguous MORECORE

  Statistics
    Each space keeps track of current and maximum system memory
    obtained via MORECORE or MMAP.

  Trim support
    Fields holding the amount of unused topmost memory that should trigger
    trimming, and a counter to force periodic scanning to release unused
    non-topmost segments.

  Locking
    If USE_LOCKS is defined, the "mutex" lock is acquired and released
    around every public call using this mspace.

  Extension support
    A Void* pointer and a size_t field that can be used to help implement
    extensions to this malloc.
*/

/* Bin types, widths and sizes */
//#define NSMALLBINS        (32U)
//#define NTREEBINS         (32U)
//#define SMALLBIN_SHIFT    (3U)
//#define SMALLBIN_WIDTH    (SIZE_T_ONE << SMALLBIN_SHIFT) => 8
//#define TREEBIN_SHIFT     (8U)
//#define MIN_LARGE_SIZE    (SIZE_T_ONE << TREEBIN_SHIFT) => 256
//#define MAX_SMALL_SIZE    (MIN_LARGE_SIZE - SIZE_T_ONE) => 255
//#define MAX_SMALL_REQUEST (MAX_SMALL_SIZE - CHUNK_ALIGN_MASK - CHUNK_OVERHEAD) => 256 - 7 - 4 => 245

__struct malloc_state {
  smallmap:         u32; 
  treemap:          u32;
  dvsize:           __size_t;
  topsize:          __size_t;
  least_addr:       __Ptr; //was a char*
  dv:               __Option<malloc_chunk>;
  top:              __Option<malloc_chunk>;
  trim_check:       __size_t;
  //release_checks:   __size_t;
  magic:            __size_t;
  smallbins:        __Array<malloc_chunk>; //mchunkptr  smallbins[(NSMALLBINS+1)*2];
  treebins:         __Array<__Option<malloc_tree_chunk>>; //tbinptr    treebins[NTREEBINS];
  footprint:        __size_t;
  max_footprint:    __size_t;
  footprint_limit:  __size_t; /* zero means no limit */
  mflags:           u32;
  seg:              malloc_segment;
  extp:             __Ptr;      /* Unused but available for extensions */
  exts:             __size_t;
}


/* ------------- Global malloc_state and malloc_params ------------------- */

/*
  malloc_params holds global properties, including those that can be
  dynamically set using mallopt. There is a single instance, mparams,
  initialized in init_mparams. Note that the non-zeroness of "magic"
  also serves as an initialization flag.
*/

__struct malloc_params {
  magic:          __size_t;
  page_size:      __size_t;
  granularity:    __size_t;
  mmap_threshold: __size_t;
  trim_threshold: __size_t;
  default_mflags: u32; // was a flag_t aka u32;
}

let mparams: malloc_params = __static malloc_params {
  magic: 0, 
  page_size: 0, 
  granularity: 0, 
  mmap_threshold: 0, 
  trim_threshold: 0, 
  default_mflags: 0
};

/* The global malloc_state used for all non-"mspace" calls */
const gm: malloc_state = __static malloc_state{
  smallmap:         0,
  treemap:          0,
  dvsize:           0,
  topsize:          0,
  least_addr:       (0 as __Ptr),
  dv:               __Null,
  top:              __Null,
  trim_check:       0,
  //release_checks:   0,
  magic:            0,
  //32 lots of malloc_chunk...
  smallbins:        __static __Array<malloc_chunk> [
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
    __static malloc_chunk{prev_foot: 0, head: 0,
      fd: 0 as __Ptr as malloc_chunk, bk: 0 as __Ptr as malloc_chunk
    },
  ],
  treebins:         __static __Array<__Option<malloc_tree_chunk>>[
      __Null, __Null, __Null, __Null, __Null, __Null, __Null, __Null, __Null, __Null, 
      __Null, __Null, __Null, __Null, __Null, __Null, __Null, __Null, __Null, __Null, 
      __Null, __Null, __Null, __Null, __Null, __Null, __Null, __Null, __Null, __Null, 
      __Null, __Null
  ],
  footprint:        0,
  max_footprint:    0,
  footprint_limit:  0,
  mflags:           0,
  seg:              __static malloc_segment{
    base: 0 as __Ptr,
    size: 0,
    next: __Null,
  },
  extp:             (0 as __Ptr),
  exts:             0,
};
//#define is_global(M)       ((M) == &_gm_)

fn is_initialized(m: malloc_state) -> Bool m.top != __Null;

/* page-align a size */
//#define page_align(S) (((S) + (mparams.page_size - SIZE_T_ONE)) & ~(mparams.page_size - SIZE_T_ONE))
fn page_align(s: __size_t) -> __size_t ((s + (mparams.page_size - 1)) & ~(mparams.page_size - 1));

/* granularity-align a size */
//#define granularity_align(S)  (((S) + (mparams.granularity - SIZE_T_ONE)) & ~(mparams.granularity - SIZE_T_ONE))
fn granularity_align(s: __size_t) -> __size_t ((s + (mparams.granularity - 1)) & ~(mparams.granularity - 1));

/*
  TOP_FOOT_SIZE is padding at the end of a segment, including space
  that may be needed to place segment records and fenceposts when new
  noncontiguous segments are added.
*/
//#define TOP_FOOT_SIZE (align_offset(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE);
const TOP_FOOT_SIZE = align_offset_size_t(TWO_SIZE_T_SIZES) + pad_request(__sizeof(malloc_segment)) + MIN_CHUNK_SIZE;

/* For sys_alloc, enough padding to ensure can malloc request on success */
//#define SYS_ALLOC_PADDING (TOP_FOOT_SIZE + MALLOC_ALIGNMENT)
const SYS_ALLOC_PADDING = TOP_FOOT_SIZE + (8 as __size_t);

//#define is_page_aligned(S) (((size_t)(S) & (mparams.page_size - SIZE_T_ONE)) == 0)
fn is_page_aligned(s: __Ptr) -> Bool ((s as __size_t) & (mparams.page_size - (1 as __size_t))) == 0;
//#define is_granularity_aligned(S) (((size_t)(S) & (mparams.granularity - SIZE_T_ONE)) == 0)
fn is_granularity_aligned(s: __Ptr) -> Bool ((s as __size_t) & (mparams.granularity - (1 as __size_t))) == 0;

/*  True if segment S holds address A */
//#define segment_holds(S, A) ((char*)(A) >= S->base && (char*)(A) < S->base + S->size)
fn segment_holds(s: malloc_segment, a: __Ptr) -> Bool (a >= s.base && a < s.base + (s.size as __Ptr));

/* Return segment holding given address */
fn segment_holding(m: malloc_state, addr: __Ptr) -> __Option<malloc_segment> {
  let o_sp: __Option<malloc_segment> = __Some(m.seg);
  while(true) {
    let sp = option.__Option_unwrap<malloc_segment>(o_sp);
    if (addr >= sp.base && addr < sp.base + (sp.size as __Ptr))
      return __Some(sp);
    o_sp = sp.next;
    if (o_sp == __Null)
      return __Null;
  }
  return __Null;
}

/* Return true if segment contains a segment link */
/*
fn has_segment_link(m: malloc_state, ss: malloc_segment) -> Bool {
  let o_sp: __Option<malloc_segment> = m.seg;
  while(true) {
    let sp = option.__Option_unwrap<malloc_segment>(o_sp);
    if ((sp as __Ptr) >= ss.base && (sp as __Ptr) < ss.base + ss.size)
      return true;
    if (sp != sp.next) 
      return false;
  }
}
*/

//#define should_trim(M,s)  (0)

/* -------------------------------  Hooks -------------------------------- */

/*
  PREACTION should be defined to return 0 on success, and nonzero on
  failure. If you are not using locking, you can redefine these to do
  anything you like.
*/
//#define PREACTION(M) (0)
//#define POSTACTION(M)

/*
  CORRUPTION_ERROR_ACTION is triggered upon detected bad addresses.
  USAGE_ERROR_ACTION is triggered on detected bad frees and
  reallocs. The argument p is an address that might have triggered the
  fault. It is ignored by the two predefined actions, but might be
  useful in custom actions that try to help diagnose errors.
*/

//#define CORRUPTION_ERROR_ACTION(m) ABORT
//#define USAGE_ERROR_ACTION(m,p) ABORT

/* -------------------------- Debugging setup ---------------------------- */

//#define check_free_chunk(M,P)
//#define check_inuse_chunk(M,P)
//#define check_malloced_chunk(M,P,N)
//#define check_mmapped_chunk(M,P)
//#define check_malloc_state(M)
//#define check_top_chunk(M,P)

/* ---------------------------- Indexing Bins ---------------------------- */
//#define is_small(s)         (((s) >> SMALLBIN_SHIFT) < NSMALLBINS)
fn is_small(s: __size_t) -> Bool s.shiftRight(3) < 32

//#define small_index(s)      (bindex_t)((s)  >> SMALLBIN_SHIFT)
fn small_index(s: __size_t) -> u32 s.shiftRight(3)

//#define small_index2size(i) ((i)  << SMALLBIN_SHIFT)
fn small_index2size(i: u32) -> __size_t {
  let out = i.shiftLeft(3)
  out
}

//#define MIN_SMALL_INDEX     (small_index(MIN_CHUNK_SIZE))
const MIN_SMALL_INDEX = small_index(MIN_CHUNK_SIZE);

/* addressing by index. See above about smallbin repositioning *_* we don't do the repositioning trick */
//#define smallbin_at(M, i)   ((sbinptr)((char*)&((M)->smallbins[(i)<<1])))
fn smallbin_at(m: malloc_state, i: u32) -> malloc_chunk m.smallbins[i];

//#define treebin_at(M,i)     (&((M)->treebins[i]))

//#define compute_tree_index(S, I)\
fn compute_tree_index(s: __size_t) -> u32 {
  const x: __size_t = s.shiftRight(8);
  if (x == 0)
    0
  else if (x > (0xFFFF as __size_t))
    31
  else {
    const k: u32 = 31 - (x.countLeadingZeros() as u32)
    k.shiftLeft(1) + (s.shiftRight(k + 7) & 1)
  }
}

/* Shift placing maximum resolved bit in a treebin at i as sign bit */
//#define leftshift_for_tree_index(i) ((i == NTREEBINS-1)? 0 : ((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i) >> 1) + TREEBIN_SHIFT - 2)))
fn leftshift_for_tree_index(i: u32) -> u32 {
  if (i == 31) 0; else 31 - (i.shiftRight(1) + 6);
}

/* The size of the smallest chunk held in bin with index i */
//#define minsize_for_tree_index(i) (SIZE_T_ONE << (((i) >> 1) + TREEBIN_SHIFT)) | (((size_t)((i) & SIZE_T_ONE)) << (((i) >> 1) + TREEBIN_SHIFT - 1))

/* ------------------------ Operations on bin maps ----------------------- */

/* bit corresponding to given index */
//#define idx2bit(i)              ((binmap_t)(1) << (i))
fn idx2bit(i: u32) -> __size_t (1 as u32).shiftLeft(i)

/* Mark/Clear bits with given index */
//#define mark_smallmap(M,i)      ((M)->smallmap |=  idx2bit(i))
//fn mark_smallmap(m: malloc_state, i: __size_t) -> Void m.smallmap |= idx2bit(i)
//#define clear_smallmap(M,i)     ((M)->smallmap &= ~idx2bit(i))
fn clear_smallmap(m: malloc_state, i: u32) -> Void m.smallmap &= ~idx2bit(i)
//#define smallmap_is_marked(M,i) ((M)->smallmap &   idx2bit(i))
fn smallmap_is_marked(m: malloc_state, i: u32) -> Bool (m.smallmap & idx2bit(i)) != 0

//#define mark_treemap(M,i)       ((M)->treemap  |=  idx2bit(i))
fn mark_treemap(m: malloc_state, i: u32) -> Void m.treemap  |=  idx2bit(i);
//#define clear_treemap(M,i)      ((M)->treemap  &= ~idx2bit(i))
fn clear_treemap(m: malloc_state, i: u32) -> Void m.treemap  &= ~idx2bit(i);
//#define treemap_is_marked(M,i)  ((M)->treemap  &   idx2bit(i))
fn treemap_is_marked(m: malloc_state, i: u32) -> Bool (m.treemap  &   idx2bit(i)) != 0

/* isolate the least set bit of a bitmap */
//#define least_bit(x)         ((x) & -(x))
fn least_bit(x: __size_t) -> __size_t x & x.unsignedNegate()

/* mask with all bits to left of least bit of x on */
//#define left_bits(x)         ((x<<1) | -(x<<1))
fn left_bits(x: __size_t) -> __size_t x.shiftLeft(1) | x.shiftLeft(1).unsignedNegate()

/* mask with all bits to left of or equal to least bit of x on */
//#define same_or_left_bits(x) ((x) | -(x))
fn same_or_left_bits(x: __size_t) -> __size_t x | x.unsignedNegate()

/* index corresponding to given bit. Use x86 asm if possible */
//#define compute_bit2idx(X, I) { unsigned int J; J = __builtin_ctz(X); I = (bindex_t)J; }
fn compute_bit2idx(x: __size_t) -> __size_t x.countTrailingZeros() as __size_t

/* ----------------------- Runtime Check Support ------------------------- */

/*
  For security, the main invariant is that malloc/free/etc never
  writes to a static address other than malloc_state, unless static
  malloc_state itself has been corrupted, which cannot occur via
  malloc (because of these checks). In essence this means that we
  believe all pointers, sizes, maps etc held in malloc_state, but
  check all of those linked or offsetted from other embedded data
  structures.  These checks are interspersed with main code in a way
  that tends to minimize their run-time cost.

  When FOOTERS is defined, in addition to range checking, we also
  verify footer fields of inuse chunks, which can be used guarantee
  that the mstate controlling malloc/free is intact.  This is a
  streamlined version of the approach described by William Robertson
  et al in "Run-time Detection of Heap-based Overflows" LISA'03
  http://www.usenix.org/events/lisa03/tech/robertson.html The footer
  of an inuse chunk holds the xor of its mstate and a random seed,
  that is checked upon calls to free() and realloc().  This is
  (probabalistically) unguessable from outside the program, but can be
  computed by any code successfully malloc'ing any chunk, so does not
  itself provide protection against code that has already broken
  security through some other means.  Unlike Robertson et al, we
  always dynamically check addresses of all offset chunks (previous,
  next, etc). This turns out to be cheaper than relying on hashes.
*/

//*_* note: these are all under the 'INSECURE' macro. In a release build, we should probably not include them.

/* Check if address a is at least as high as any from MORECORE or MMAP */
//#define ok_address(M, a) ((char*)(a) >= (M)->least_addr)
fn ok_address(m: malloc_state, a: __Ptr) -> Bool a >= m.least_addr;

/* Check if address of next chunk n is higher than base chunk p */
//#define ok_next(p, n)    ((char*)(p) < (char*)(n))
fn ok_next(p: __Ptr, n: __Ptr) -> Bool p < n;

/* Check if p has inuse status */
//#define ok_inuse(p)     is_inuse(p)
fn ok_inuse(p: malloc_chunk) -> Bool is_inuse(p);

/* Check if p has its pinuse bit on */
//#define ok_pinuse(p)     pinuse(p)
fn ok_pinuse(p: malloc_chunk) -> Bool pinuse(p); 

//#define ok_magic(M)      (1)

//#define mark_inuse_foot(M,p,s)

/* Set cinuse bit and pinuse bit of next chunk */
//#define set_inuse(M,p,s)  ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT), ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)
fn set_inuse(m: malloc_state, p: malloc_chunk, s: __size_t) -> Void {
  p.head = (p.head & 1) | s | 2
  (((p as __Ptr) + (s as __Ptr)) as malloc_chunk).head |= 1
}

/* Set cinuse and pinuse of this chunk and pinuse of next chunk */
//#define set_inuse_and_pinuse(M,p,s)  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),  ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)
fn set_inuse_and_pinuse(m: malloc_state, p: malloc_chunk, s: __size_t) -> Void {
  p.head = s | 1 | 2
  (((p as __Ptr) + (s as __Ptr)) as malloc_chunk).head |= 1
}

fn tree_set_inuse_and_pinuse(m: malloc_state, p: malloc_tree_chunk, s: __size_t) -> Void {
  p.head = s | 1 | 2
  (((p as __Ptr) + (s as __Ptr)) as malloc_tree_chunk).head |= 1
}


/* Set size, cinuse and pinuse bit of this chunk */
//#define set_size_and_pinuse_of_inuse_chunk(M, p, s)  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT))
fn set_size_and_pinuse_of_inuse_chunk(m: malloc_state, p: malloc_chunk, s: __size_t) -> Void p.head = s | 1 | 2
fn tree_set_size_and_pinuse_of_inuse_chunk(m: malloc_state, p: malloc_tree_chunk, s: __size_t) -> Void p.head = s | 1 | 2

/* ---------------------------- setting mparams -------------------------- */

/* Initialize mparams */
fn init_mparams() -> Bool {
  if (mparams.magic == 0) {
    let psize: __size_t = 65536  //malloc_getpagesize
    let gsize: __size_t = 65536  //((DEFAULT_GRANULARITY != 0)? DEFAULT_GRANULARITY : psize);
    mparams.granularity = gsize;
    mparams.page_size = psize;
    mparams.mmap_threshold = 0xffffffff //DEFAULT_MMAP_THRESHOLD
    mparams.trim_threshold = 0xffffffff //DEFAULT_TRIM_THRESHOLD
    mparams.default_mflags = 0  //USE_LOCK_BIT|USE_MMAP_BIT;

    /* Set up lock for main malloc area */
    gm.mflags = mparams.default_mflags
    // *_* there was a lot about random numbers and volatile writes here. I presume that this is when you hit malloc from
    // multiple threads. I removed that for the moment
    mparams.magic = 1
  }

  true;
}

/* Ensure mparams initialized */
fn ensure_initialization() -> Void { (mparams.magic != 0) || init_mparams(); }

/* ------------------------- Debugging Support --------------------------- */
// *_* not implemented at present

/* ----------------------------- statistics ------------------------------ */

// *_* This has a different api - the dlmalloc allocates on the stack, but I can't do that, so
// I accept a pre-allocated container and write in it
fn internal_mallinfo(m: malloc_state, nm: mallinfo) -> Void {
  ensure_initialization();
  //check_malloc_state(m);
  if (is_initialized(m)) {
    let nfree = (1 as __size_t); /* top always free */
    let mfree = m.topsize + TOP_FOOT_SIZE;
    let sum = mfree;

    //FIXME option handling
    let o_s = __Some(m.seg)
    while (option.__Option_isSome(o_s)) {
      let s = option.__Some_unwrap<malloc_segment>(o_s);
      let q = align_as_chunk(s.base);
      while (segment_holds(s, q as __Ptr) && __Some(q) != m.top && q.head != FENCEPOST_HEAD) {
        let sz = chunksize(q);
        sum += sz;
        if (!is_inuse(q)) {
          mfree += sz;
          nfree+= 1
        }
        q = next_chunk(q);
      }
      o_s = s.next;
    }

    nm.arena    = sum;
    nm.ordblks  = nfree;
    //nm.hblkhd   = m.footprint - sum;
    nm.usmblks  = m.max_footprint;
    nm.uordblks = m.footprint - mfree;
    nm.fordblks = mfree;
    nm.keepcost = m.topsize;
  }
}

/* ----------------------- Operations on smallbins ----------------------- */

// *_* dlmalloc defines these as macros. I obviously don't. I guess I shall
// see if I can inline as well
fn insert_small_chunk(m: malloc_state, p: malloc_chunk, s: __size_t) -> Void {
  let i  = small_index(s);
  let b = smallbin_at(m, i);
  let f = b;
  //assert(S >= MIN_CHUNK_SIZE);
  if (!smallmap_is_marked(m, i))
    m.smallmap |= idx2bit(i);
  else if (ok_address(m, b.fd as __Ptr))
    f = b.fd;
  else {
    __trap();
  }
  b.fd = p;
  f.bk = p;
  p.fd = f;
  p.bk = b;
}

/* Unlink a chunk from a smallbin  */
fn unlink_small_chunk(m: malloc_state, p: malloc_chunk, s: __size_t) -> Void {
  let f = p.fd
  let b = p.bk
  let i = small_index(s)
  //assert(p != b);
  //assert(p != f);
  //assert(chunksize(p) == small_index2size(i));
  if (
    (f as __Ptr) == (smallbin_at(m,i) as __Ptr)
    || (ok_address(m, f as __Ptr) && (f.bk as __Ptr) == (p as __Ptr))
  ) {
    if ((b as __Ptr) == (f as __Ptr)) {
      clear_smallmap(m, i)
    } else if (
      (b as __Ptr) == (smallbin_at(m,i) as __Ptr) 
      || (ok_address(m, b as __Ptr) && (b.fd as __Ptr) == (p as __Ptr))
    ) {
      f.bk = b
      b.fd = f
    } else __trap()
  } else __trap()
}

/* Unlink the first chunk from a smallbin */
fn unlink_first_small_chunk(m: malloc_state, b: malloc_chunk, p: malloc_chunk, i: u32) -> Void {
  let f = p.fd
  //assert(P != B)
  //assert(P != F);
  //assert(chunksize(P) == small_index2size(I));
  if ((b as __Ptr) == (f as __Ptr)) {
    clear_smallmap(m, i)
  }
  else if (ok_address(m, f as __Ptr) && (f.bk as __Ptr) == (p as __Ptr)) {
    f.bk = b
    b.fd = f
  } else __trap()
}

/* Replace dv node, binning the old one */
/* Used only when dvsize known to be small */
fn replace_dv(m: malloc_state, p: malloc_chunk, s: __size_t) -> Void {
  //let dvs = m.dvsize
  const dv = m.dv
  if (option.__Option_isSome(dv)) {
    let dvs = m.dvsize
    insert_small_chunk(m, option.__Some_unwrap(dv), dvs)
  }
  m.dvsize = s
  m.dv = __Some(p)
}

/* ------------------------- Operations on trees ------------------------- */

/* Insert chunk into tree */
fn insert_large_chunk(m: malloc_state, x: malloc_tree_chunk, s: __size_t) -> Void {
  let i = compute_tree_index(s)
  x.index = i
  x.child_0 = __Null
  x.child_1 = __Null
  if (!treemap_is_marked(m, i)) {
    mark_treemap(m, i)
    m.treebins[i] = __Some(x)
    //wow
    x.parent = __Some(MAX_SIZE_T as __Ptr as malloc_tree_chunk)
    x.fd = x
    x.bk = x
  } else {
    let o_t = m.treebins[i]
    let k = s.shiftLeft(leftshift_for_tree_index(i))
    while(true) {
      let t = option.__Option_unwrap(o_t);
      if (tree_chunksize(t) != s) {
        let child_index = (k.shiftRight(31) & (1 as __size_t)).truncateToSigned()
        k = k.shiftLeft(1)
        let child_ptr = if (child_index==0) t.child_0; else t.child_1
        if (option.__Option_isSome(child_ptr))
          o_t = child_ptr
        else {
          if (child_index==0) t.child_0 = __Some(x); else t.child_1 = __Some(x)
          x.parent = __Some(t)
          x.fd = x
          x.bk = x
          break
        }
      } else {
        let f = t.fd
        if (ok_address(m, t as __Ptr) && ok_address(m, f as __Ptr)) {
          t.fd = x
          f.bk = x
          x.fd = f
          x.bk = t
          x.parent = __Null
          break
        } else {
          __trap()
        }
      }
    }
  }
}

/*
  Unlink steps:

  1. If x is a chained node, unlink it from its same-sized fd/bk links
     and choose its bk node as its replacement.
  2. If x was the last node of its size, but not a leaf node, it must
     be replaced with a leaf node (not merely one with an open left or
     right), to make sure that lefts and rights of descendents
     correspond properly to bit masks.  We use the rightmost descendent
     of x.  We could use any other leaf, but this is easy to locate and
     tends to counteract removal of leftmosts elsewhere, and so keeps
     paths shorter than minimally guaranteed.  This doesn't loop much
     because on average a node in a tree is near the bottom.
  3. If x is the base of a chain (i.e., has parent links) relink
     x's parent and children to x's replacement (or null if none).
*/

fn unlink_large_chunk(m: malloc_state, x: malloc_tree_chunk) -> Void {
  let o_xp = x.parent
  let o_r: __Option<malloc_tree_chunk> = __Null;
  if (x.bk as __Ptr != x as __Ptr) {
    let f = x.fd
    let r = x.bk
    o_r = __Some(r)
    if (ok_address(m, f as __Ptr) && (f.bk as __Ptr == x as __Ptr) && (r.fd as __Ptr == x as __Ptr)) {
      f.bk = r
      r.fd = f
    } else {
      __trap()
    }
  } else {
    let o_parent_pointer: __Option<malloc_tree_chunk> = __Null
    let parent_child_index = -1
    let loop = false
    if(x.child_1 != __Null) {
        o_parent_pointer = __Some(x)
        o_r = x.child_1
        parent_child_index = 1
        loop = true
    } else if(x.child_0 != __Null) {
        o_parent_pointer = __Some(x)
        o_r = x.child_0
        parent_child_index = 0
        loop = true
    }  

    while (loop && option.__Option_isSome(o_r)) {
      let r = option.__Some_unwrap(o_r)
      if(r.child_1 != __Null) {
        o_parent_pointer = o_r
        o_r = r.child_1
        parent_child_index = 1
        continue
      }
      if(r.child_0 != __Null) {
        o_parent_pointer = o_r
        o_r = r.child_0
        parent_child_index = 0
        continue
      }
      loop = false
    }

    if(option.__Option_isSome(o_parent_pointer)) {
      let parent_pointer = option.__Some_unwrap(o_parent_pointer)
      if (parent_child_index == 0)
        parent_pointer.child_0 = __Null 
      else 
        parent_pointer.child_1 = __Null 
    }
  }
  if (option.__Option_isSome(o_xp)) {
    let xp = option.__Some_unwrap(o_xp)
    let treebinIndex = x.index;
    let treebin = m.treebins[treebinIndex]
    if (__Some(x) == treebin) {
      m.treebins[treebinIndex] = o_r
      if (option.__Option_isNull(o_r))
        clear_treemap(m, treebinIndex);
    } else if (ok_address(m, xp as __Ptr)) {
      if (xp.child_0 == __Some(x))
        xp.child_0 = o_r
      else
        xp.child_1 = o_r
    } else
      __trap()
    if (option.__Option_isSome(o_r)) {
      let r = option.__Some_unwrap(o_r)
      if (ok_address(m, r as __Ptr)) {
        r.parent = o_xp
        let o_c0 = x.child_0
        if (option.__Option_isSome(o_c0)) {
          let c0 = option.__Some_unwrap(o_c0)
          if (ok_address(m, c0 as __Ptr)) {
            r.child_0 = o_c0
            c0.parent = o_r
          } else
            __trap()
        }
        let o_c1 = x.child_1
        if (option.__Option_isSome(o_c1)) {
          let c1 = option.__Some_unwrap(o_c1)
          if (ok_address(m, c1 as __Ptr)) {
            r.child_1 = o_c1
            c1.parent = o_r
          } else
            __trap()
        }
      }
    }
  }
}

/* Relays to large vs small bin operations */

fn insert_chunk(m: malloc_state, p: malloc_chunk, s: __size_t) -> Void {
  if (is_small(s)) insert_small_chunk(m, p, s)
  else { let tp = p as __Ptr as malloc_tree_chunk; insert_large_chunk(m, tp, s); }
}

fn unlink_chunk(m: malloc_state, p: malloc_chunk, s: __size_t) -> Void {
  if (is_small(s)) unlink_small_chunk(m, p, s)
  else { let tp = p as __Ptr as malloc_tree_chunk; unlink_large_chunk(m, tp); }
}

/* Relays to internal calls to malloc/free from realloc, memalign etc */

//#define internal_malloc(m, b) dlmalloc(b)
//#define internal_free(m, mem) dlfree(mem)

/* -------------------------- mspace management -------------------------- */

/* Initialize top chunk and its size */
fn init_top(m: malloc_state, p: malloc_chunk, psize: __size_t ) -> Void {
  /* Ensure alignment */
  let offset = align_offset(chunk2mem(p));
  p = ((p as __Ptr) + offset) as malloc_chunk;
  psize -= offset as __size_t;

  m.top = __Some(p);
  m.topsize = psize;
  p.head = psize | 1;
  /* set size of fake trailing chunk holding overhead space only once */
  let c = chunk_plus_offset(p, psize)
  c.head = TOP_FOOT_SIZE;
  m.trim_check = mparams.trim_threshold; /* reset on each update */
}

/* Initialize bins for a new mstate that is otherwise zeroed out */
fn init_bins(m: malloc_state) -> Void {
  /* Establish circular links for smallbins */
  let i: u32 = 0;
  while(i < 32) {
    let bin = smallbin_at(m,i);
    bin.fd = bin.bk = bin;
    i += 1;
  }
}

/* Allocate chunk and prepend remainder with chunk in successor base. */
fn prepend_alloc(m: malloc_state, newbase: __Ptr, oldbase: __Ptr, nb: __size_t) -> __Ptr {
  let p = align_as_chunk(newbase)
  let oldfirst = align_as_chunk(oldbase)
  let psize: __size_t = ((oldfirst as __Ptr) - (p as __Ptr)) as __size_t
  let q = chunk_plus_offset(p, nb)
  let qsize = psize - nb;
  set_size_and_pinuse_of_inuse_chunk(m, p, nb)

  //assert((char*)oldfirst > (char*)q);
  //assert(pinuse(oldfirst));
  //assert(qsize >= MIN_CHUNK_SIZE);

  /* consolidate remainder with first chunk of old base */
  if (__Some(oldfirst) == m.top) {
    m.topsize += qsize
    const tsize = m.topsize
    m.top = __Some(q)
    q.head = tsize | 1
    //check_top_chunk(m, q)
  } else if (__Some(oldfirst) == m.dv) {
    m.dvsize += qsize
    const dsize = m.dvsize
    m.dv = __Some(q)
    set_size_and_pinuse_of_free_chunk(q, dsize)
  } else {
    if (!is_inuse(oldfirst)) {
      const nsize = chunksize(oldfirst)
      unlink_chunk(m, oldfirst, nsize)
      oldfirst = chunk_plus_offset(oldfirst, nsize)
      qsize += nsize
    }
    set_free_with_pinuse(q, qsize, oldfirst)
    insert_chunk(m, q, qsize)
    //check_free_chunk(m, q)
  }

  //check_malloced_chunk(m, chunk2mem(p), nb)
  chunk2mem(p)
}

/* Add a segment to hold a new noncontiguous region */
fn add_segment(m: malloc_state, tbase: __Ptr, tsize: __size_t) -> Void {
  /*
  // Determine locations and sizes of segment, fenceposts, old top 
  let old_top = m.top as __Ptr
  let o_oldsp = segment_holding(m, old_top)
  let oldsp = option.__Option_unwrap(o_oldsp)
  let old_end = oldsp.base + (oldsp.size as __Ptr)
  let ssize = pad_request(__sizeof(malloc_segment))
  let rawsp = old_end - ((ssize + 16 + 7) as __Ptr)
  let offset = align_offset(chunk2memPtr(rawsp))
  let asp = rawsp + offset
  let csp = if (asp < (old_top + (MIN_CHUNK_SIZE as __Ptr))) old_top; else asp
  let sp: malloc_chunk = csp as malloc_chunk
  let ss: malloc_segment = chunk2mem(sp) as malloc_segment
  let tnext = chunk_plus_offset(sp, ssize)
  let p = tnext
  let nfences = 0

  // reset top to new space
  init_top(m, tbase as malloc_chunk, tsize - TOP_FOOT_SIZE);

  // Set up segment record
  //assert(is_aligned(ss));
  set_size_and_pinuse_of_inuse_chunk(m, sp, ssize);
  *ss = m->seg; // Push current record
  m.seg.base = tbase;
  m.seg.size = tsize;
  m.seg.next = __Some(ss)

  // Insert trailing fenceposts
  while(true) {
    let nextp = chunk_plus_offset(p, SIZE_T_SIZE)
    p.head = FENCEPOST_HEAD
    nfences += 1
    
    //if ((char*)(&(nextp->head)) < old_end)
    if(chunk_plus_offset(p, SIZE_T_SIZE * 2) as __Ptr < old_end)
      p = nextp
    else
      break
  }
  //assert(nfences >= 2);

  // Insert the rest of old top into a bin as an ordinary free chunk
  if (csp != old_top) {
    let q = old_top as malloc_chunk
    let psize = (csp - old_top) as __size_t
    let tn = chunk_plus_offset(q, psize)
    set_free_with_pinuse(q, psize, tn)
    insert_chunk(m, q, psize)
  }

  //check_top_chunk(m, m->top);
  */
  __trap()
}

/* -------------------- Alternative MORECORE functions ------------------- */

/*
  Guidelines for creating a custom version of MORECORE:

  * For best performance, MORECORE should allocate in multiples of pagesize.
  * MORECORE may allocate more memory than requested. (Or even less,
      but this will usually result in a malloc failure.)
  * MORECORE must not allocate memory when given argument zero, but
      instead return one past the end address of memory from previous
      nonzero call.
  * For best performance, consecutive calls to MORECORE with positive
      arguments should return increasing addresses, indicating that
      space has been contiguously extended.
  * Even though consecutive calls to MORECORE need not return contiguous
      addresses, it must be OK for malloc'ed chunks to span multiple
      regions in those cases where they do happen to be contiguous.
  * MORECORE need not handle negative arguments -- it may instead
      just return MFAIL when given negative arguments.
      Negative arguments are always multiples of pagesize. MORECORE
      must not misinterpret negative args as large positive unsigned
      args. You can suppress all such calls from even occurring by defining
      MORECORE_CANNOT_TRIM,

*/

fn CALL_MORECORE(sz: Int) -> __Ptr {
  if (sz > 0) {
    const numPages = (sz / PAGE_SIZE) + 1;
    const r = __memoryGrow(0, numPages);
    if (r == 0xffffffff) {
      __trap();
    }
    r as __Ptr
  } else if (sz < 0) {
    CMFAIL
  } else {
    ((__memorySize() * PAGE_SIZE) + 1) as __Ptr
  }
}
/*
    if(memTop + sz > memBottom) {
        const numPages = (sz / PAGE_SIZE) + 1;
        const r = __memoryGrow(0, numPages);
        if (r == -1) {
            __trap();
        }
        memBottom = __memorySize() * PAGE_SIZE;
    }

    const out = memTop;
    memTop += sz;
    out;
}
*/

/* -------------------------- System allocation -------------------------- */

/* Get memory from system using MORECORE or MMAP */
fn sys_alloc(m: malloc_state, nb: __size_t) -> __Ptr {
  let tbase = CMFAIL
  let tsize: __size_t = 0

  ensure_initialization();

  /* allocation size */
  let asize = granularity_align(nb + SYS_ALLOC_PADDING)

  if (asize <= nb)
    __trap() /* wraparound */
  
  /*
    Try getting memory in any of three ways (in most-preferred to
    least-preferred order):
    1. A call to MORECORE that can normally contiguously extend memory.
       (disabled if not MORECORE_CONTIGUOUS or not HAVE_MORECORE or
       or main space is mmapped or a previous contiguous call failed)
    2. A call to MMAP new space (disabled if not HAVE_MMAP).
       Note that under the default settings, if MORECORE is unable to
       fulfill a request, and HAVE_MMAP is true, then mmap is
       used as a noncontiguous system allocator. This is a useful backup
       strategy for systems with holes in address spaces -- in this case
       sbrk cannot contiguously expand the heap, but mmap may be able to
       find space. *_* not used
    3. A call to MORECORE that cannot usually contiguously extend memory.
       (disabled if not HAVE_MORECORE) *_* not used

   In all cases, we need to request enough bytes from system to ensure
   we can malloc nb bytes upon success, so pad with enough space for
   top_foot, plus alignment-pad to make sure we don't lose bytes if
   not on boundary, and round this up to a granularity unit.
  */

  let br = CMFAIL
  let ssize = asize // sbrk call size
  let o_ss = if(m.top == __Null) __Null; else segment_holding(m, m.top as __Ptr)
  //ACQUIRE_MALLOC_GLOBAL_LOCK();

  if (option.__Option_isNull(o_ss)) {  // First time through or recovery
    let base = CALL_MORECORE(0)
    if (base != CMFAIL) {
      // Adjust to end on a page boundary
      if (!is_page_aligned(base))
        ssize += (page_align(base as __size_t) - (base as __size_t))
      let fp = m.footprint + ssize // recheck limits
      if (ssize > nb 
        && ssize < 2147483647 // HALF_MAX_SIZE_T - inlined to make the type guard work FIXME64BIT
        && (m.footprint_limit == 0 || (fp > m.footprint && fp <= m.footprint_limit))
      ) {
        br = CALL_MORECORE(ssize)
        if (br == base) {
          tbase = base
          tsize = ssize
        }
      }
    }
  } else {
    let ss = option.__Some_unwrap(o_ss)
    // Subtract out existing available top space from MORECORE request.
    ssize = granularity_align(nb - m.topsize + SYS_ALLOC_PADDING)
    // Use mem here only if it did continuously extend old space
    if (ssize < 2147483647 // HALF_MAX_SIZE_T - inlined to make the type guard work FIXME64BIT
    ) {
      br = CALL_MORECORE(ssize)
      if (br == (ss.base+(ss.size as __Ptr))) {
        tbase = br;
        tsize = ssize;
      }
    }
  }

  if (tbase == CMFAIL) {    // Cope with partial failure
    if (br != CMFAIL) {    // Try to use/extend the space we did get
      if (ssize < 2147483647 // HALF_MAX_SIZE_T - inlined to make the type guard work FIXME64BIT
        && ssize < nb + SYS_ALLOC_PADDING) {
        let esize = granularity_align(nb + SYS_ALLOC_PADDING - ssize);
        if (
          esize < 2147483647 // HALF_MAX_SIZE_T - inlined to make the type guard work FIXME64BIT
          ) {
          let end = CALL_MORECORE(esize)
          if (end != CMFAIL)
            ssize += esize
          else {            // Can't use; try to release
            //CALL_MORECORE(-ssize)
            br = CMFAIL
          }
        }
      }
    }
    if (br != CMFAIL) {    // Use the space we did get
      tbase = br
      tsize = ssize
    } else
      __trap() 
  }
  //RELEASE_MALLOC_GLOBAL_LOCK();

  if (tbase != CMFAIL) {
    m.footprint += tsize
    if (m.footprint > m.max_footprint)
      m.max_footprint = m.footprint;

    if (!is_initialized(m)) { 
      // first-time initialization
      if (m.least_addr == (0 as __Ptr) || tbase < m.least_addr)
        m.least_addr = tbase
      m.seg.base = tbase
      m.seg.size = tsize
      m.magic = mparams.magic
      init_bins(m)
      init_top(m, tbase as malloc_chunk, tsize - TOP_FOOT_SIZE)
    } else {
      // Try to merge with an existing segment
      let o_sp = __Some(m.seg);
      while (option.__Option_isSome(o_sp)) {
        let sp = option.__Some_unwrap(o_sp);
        if(tbase != sp.base + (sp.size as __Ptr))
          o_sp = sp.next
        else
          break
      }
      if (option.__Option_isSome(o_sp) &&
          segment_holds(option.__Option_unwrap(o_sp), m.top as __Ptr)) { 
        // append
        let sp = option.__Some_unwrap(o_sp);
        sp.size += tsize
        init_top(m, m.top as __Ptr as malloc_chunk, m.topsize + tsize);
      } else
      __trap()
    }

    if (nb < m.topsize) { 
      // Allocate from new or extended top space
      m.topsize -= nb
      let rsize = m.topsize;
      let o_p = m.top
      let p = option.__Option_unwrap(o_p)
      let r = chunk_plus_offset(p, nb)
      m.top = __Some(r)
      r.head = rsize | 1
      set_size_and_pinuse_of_inuse_chunk(m, p, nb)
      //check_top_chunk(m, m->top)
      //check_malloced_chunk(m, chunk2mem(p), nb)
      return chunk2mem(p)
    }
  }

  __trap()
}

/* -----------------------  system deallocation -------------------------- */

/* Consolidate and bin a chunk. Differs from exported versions
   of free mainly in that the chunk need not be marked as inuse.
*/
fn dispose_chunk(m: malloc_state, p: malloc_chunk, psize: __size_t) -> Void {
  let next = chunk_plus_offset(p, psize)
  if (!pinuse(p)) {
    let prevsize = p.prev_foot
    let prev = chunk_minus_offset(p, prevsize)
    psize += prevsize
    p = prev
    if (ok_address(m, prev as __Ptr)) { /* consolidate backward */
      if (p as __Ptr != m.dv as __Ptr) {
        unlink_chunk(m, p, prevsize);
      } else if ((next.head & 3) == 3) {
        m.dvsize = psize
        set_free_with_pinuse(p, psize, next)
        return
      }
    } else {
      __trap()
      return;
    }
  }
  if (ok_address(m, next as __Ptr)) {
    if (!cinuse(next)) {  /* consolidate forward */
      if (next as __Ptr == m.top as __Ptr) {
        m.topsize += psize
        let tsize = m.topsize
        m.top = __Some(p)
        p.head = tsize | 1
        if (p as __Ptr == m.dv as __Ptr) {
          m.dv = __Null
          m.dvsize = 0
        }
        return
      } else if (next as __Ptr == m.dv as __Ptr) {
        m.dvsize += psize
        let dsize = m.dvsize
        m.dv = __Some(p)
        set_size_and_pinuse_of_free_chunk(p, dsize)
        return
      } else {
        let nsize = chunksize(next)
        psize += nsize
        unlink_chunk(m, next, nsize)
        set_size_and_pinuse_of_free_chunk(p, psize)
        if (p as __Ptr == m.dv as __Ptr) {
          m.dvsize = psize
          return
        }
      }
    } else {
      set_free_with_pinuse(p, psize, next)
    }
    insert_chunk(m, p, psize)
  } else {
    __trap()
  }
}

/* ---------------------------- malloc --------------------------- */

/* allocate a large request from the best fitting chunk in a treebin */
fn tmalloc_large(m: malloc_state, nb: __size_t) -> __Ptr{
  let o_v: __Option<malloc_tree_chunk> = __Null
  let rsize = nb.unsignedNegate() /* Unsigned negation */
  //tchunkptr t;
  let idx = compute_tree_index(nb)
  let o_t = m.treebins[idx]
  if (option.__Option_isSome(o_t)) {
    /* Traverse tree for this bin looking for node with size == nb */
    let sizebits = nb.shiftLeft(leftshift_for_tree_index(idx))
    let rst: __Option<malloc_tree_chunk> = __Null  /* The deepest untaken right subtree */
    while(true) {
      let t = option.__Option_unwrap(o_t)
      let trem = tree_chunksize(t) - nb
      if (trem < rsize) {
        o_v = o_t
        rsize = trem
        if (rsize == 0)
          break
      }
      let rt = t.child_1
      let child_index = (sizebits.shiftRight(SIZE_T_BITSIZE-1)) & 1
      o_t = if(child_index == 0) t.child_0; else t.child_1
      if (option.__Option_isSome(rt) && (rt as __Ptr) != (t as __Ptr))
        rst = rt;
      if (o_t == __Null) {
        o_t = rst /* set t to least subtree holding sizes > nb */
        break
      }
      sizebits = sizebits.shiftLeft(1)
    }
  }
  if (o_t == __Null && option.__Option_isNull(o_v)) { /* set t to root of next non-empty treebin */
    let leftbits = left_bits(idx2bit(idx)) & m.treemap
    if (leftbits != 0) {
      let leastbit = least_bit(leftbits);
      let i = compute_bit2idx(leastbit)
      o_t = m.treebins[i]
    }
  }

  while (option.__Option_isSome(o_t)) { /* find smallest of tree or subtree */
    let t = option.__Some_unwrap(o_t)
    let trem = tree_chunksize(t) - nb
    if (trem < rsize) {
      rsize = trem;
      o_v = o_t
    }
    o_t = leftmost_child(t)
  }

  /*  If dv is a better fit, return 0 so malloc will use it */
  if (option.__Option_isSome(o_v) && rsize < (m.dvsize - nb)) {
    let v = option.__Some_unwrap(o_v)
    if (ok_address(m, v as __Ptr)) { /* split */
      let r = tree_chunk_plus_offset(v, nb)
      //assert(chunksize(v) == rsize + nb);
      if (ok_next(v as __Ptr, r as __Ptr)) {
        unlink_large_chunk(m, v);
        if (rsize < MIN_CHUNK_SIZE)
          tree_set_inuse_and_pinuse(m, v, (rsize + nb));
        else {
          tree_set_size_and_pinuse_of_inuse_chunk(m, v, nb);
          tree_set_size_and_pinuse_of_free_chunk(r, rsize);
          if (is_small(rsize)) {
            let tp = r as __Ptr as malloc_chunk; 
            insert_small_chunk(m, tp, rsize)
          } else { 
            insert_large_chunk(m, r, rsize); 
          }
        }
        return tree_chunk2mem(v)
      }
    }
    __trap()
  }
  return 0 as __Ptr
}

/* allocate a small request from the best fitting chunk in a treebin */
fn tmalloc_small(m: malloc_state, nb: __size_t) -> __Ptr {
  //tchunkptr t, v;
  //size_t rsize;
  //bindex_t i;
  let leastbit = least_bit(m.treemap)
  let i = compute_bit2idx(leastbit)
  let o_v = m.treebins[i]
  let o_t = m.treebins[i]

  let t = option.__Option_unwrap(o_t)
  let rsize = tree_chunksize(t) - nb

  o_t = leftmost_child(t)
  while(option.__Option_isSome(o_t)){
    let t = option.__Some_unwrap(o_t)
    let trem = tree_chunksize(t) - nb
    if (trem < rsize) {
      rsize = trem;
      o_v = o_t;
    }
    o_t = leftmost_child(t)
  }

  if (ok_address(m, o_v as __Ptr)) {
    let v = option.__Option_unwrap(o_v)
    let r = tree_chunk_plus_offset(v, nb)
    //assert(chunksize(v) == rsize + nb);
    if (ok_next(v as __Ptr, r as __Ptr)) {
      unlink_large_chunk(m, v)
      if (rsize < MIN_CHUNK_SIZE)
        tree_set_inuse_and_pinuse(m, v, (rsize + nb));
      else {
        tree_set_size_and_pinuse_of_inuse_chunk(m, v, nb);
        tree_set_size_and_pinuse_of_free_chunk(r, rsize);
        replace_dv(m, r as __Ptr as malloc_chunk, rsize);
      }
      return tree_chunk2mem(v)
    }
  }

  __trap()
}
