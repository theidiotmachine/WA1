import {*} from "./option"

const PAGE_SIZE: __size_t = 65536 as __size_t;

//this is the pointer to the first available free address
let memTop: __ptr = __memorySize() * PAGE_SIZE;

//this is the pointer to the last available free address
let memBottom: __ptr = __memorySize() * PAGE_SIZE;
/*
function sbrk(sz: int): __ptr<0> {
    if(memTop + sz > memBottom) {
        const numPages = (sz / PAGE_SIZE) + 1;
        const r = __memoryGrow(0, numPages);
        if (r == -1) {
            __trap();
        }
        memBottom = __memorySize() * PAGE_SIZE;
    }

    const out = memTop;
    memTop += sz;
    out;
}
*/
/*
  This is a version (aka dlmalloc) of malloc/free/realloc written by
  Doug Lea and released to the public domain, as explained at
  http://creativecommons.org/publicdomain/zero/1.0/ Send questions,
  comments, complaints, performance data, etc to dl@cs.oswego.edu

* This came from Version 2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea
  at ftp://gee.cs.oswego.edu/pub/misc/malloc.c

* I ported this partly as a test of WA1 (it was a good one and found 
  many bugs) and partly to have a production quality malloc. The 
  original uses many macros. I do not have macros, so I used 
  functions and consts. It will be slow, as a result.

* WA1 Preprocessor values:
WIN32: undefined
DLMALLOC_EXPORT: ???
MALLOC_ALIGNMENT: 8
MSPACES: 0
ONLY_MSPACES: 0

USE_LOCKS                default: 0 (false)
  Causes each call to each public routine to be surrounded with
  pthread or WIN32 mutex lock/unlock. (If set true, this can be
  overridden on a per-mspace basis for mspace versions.) If set to a
  non-zero value other than 1, locks are used, but their
  implementation is left out, so lock functions must be supplied manually,
  as described below.

USE_LOCKS: 0

USE_SPIN_LOCKS: 0
USE_RECURSIVE_LOCKS: 0
LOCK_AT_FORK: 0
FOOTERS: 0
INSECURE: 0 (*)
USE_DL_PREFIX: undefined
MALLOC_INSPECT_ALL: undefined
ABORT: __trap()

PROCEED_ON_ERROR           default: defined as 0 (false)
  Controls whether detected bad addresses cause them to bypassed
  rather than aborting. If set, detected bad arguments to free and
  realloc are ignored. And all bookkeeping information is zeroed out
  upon a detected overwrite of freed heap space, thus losing the
  ability to ever return it from malloc again, but enabling the
  application to proceed. If PROCEED_ON_ERROR is defined, the
  static variable malloc_corruption_error_count is compiled in
  and can be examined to see if errors have occurred. This option
  generates slower code than the default abort policy.

PROCEED_ON_ERROR: 0

DEBUG: undefined
ABORT_ON_ASSERT_FAILURE: 1
MALLOC_FAILURE_ACTION: no op
HAVE_MORECORE: 1
MORECORE: sbrk

MORECORE_CONTIGUOUS       default: 1 (true) if HAVE_MORECORE
  If true, take advantage of fact that consecutive calls to MORECORE
  with positive arguments always return contiguous increasing
  addresses.  This is true of unix sbrk. It does not hurt too much to
  set it true anyway, since malloc copes with non-contiguities.
  Setting it false when definitely non-contiguous saves time
  and possibly wasted space it would take to discover this though.

MORECORE_CONTIGUOUS: 1

MORECORE_CANNOT_TRIM      default: NOT defined
  True if MORECORE cannot release space back to the system when given
  negative arguments. This is generally necessary only if you are
  using a hand-crafted MORECORE function that cannot handle negative
  arguments.

MORECORE_CANNOT_TRIM: 1 (*)

NO_SEGMENT_TRAVERSAL: 0
HAVE_MMAP: 0
HAVE_MREMAP: 0
MMAP_CLEARS: 0
USE_BUILTIN_FFS: 1 (*)
malloc_getpagesize: 64k
USE_DEV_RANDOM: 0
NO_MALLINFO: 0 (*)
MALLINFO_FIELD_TYPE: __ptr<0>
NO_MALLOC_STATS: 1 (*)
REALLOC_ZERO_BYTES_FREES: undefined
LACKS_*: ???
DEFAULT_GRANULARITY: 64k
DEFAULT_TRIM_THRESHOLD: 2M
DEFAULT_MMAP_THRESHOLD: ???
MAX_RELEASE_CHECK_RATE: MAX_SIZE_T (*)
*/

const MAX_SIZE_T: __size_t = 0xffffffff as __size_t;

__struct mallinfo {
    arena: __size_t;    /* non-mmapped space allocated from system */
    ordblks: __size_t;  /* number of free chunks */
    usmblks: __size_t;  /* maximum total allocated space */
    uordblks: __size_t; /* total allocated space */
    fordblks: __size_t; /* total free space */
    keepcost: __size_t; /* releasable (via malloc_trim) space */
}

/* The byte and bit size of a size_t */
//const SIZE_T_SIZE: __size_t = 4;
//const SIZE_T_BITSIZE: __size_t = 32;

/* Some constants coerced to size_t */
/* Annoying but necessary to avoid errors on some platforms */
//const SIZE_T_ZERO: __size_t =          0;
//const SIZE_T_ONE: __ptr<0> =           1;
//const SIZE_T_TWO: __ptr<0> =           2;
//const SIZE_T_FOUR: __ptr<0> =          4;
//const TWO_SIZE_T_SIZES: __ptr<0> =     8;
//const FOUR_SIZE_T_SIZES: __ptr<0> =    16;
//const SIX_SIZE_T_SIZES: __ptr<0> =     24;
//const HALF_MAX_SIZE_T: __ptr<0> =      0xffffffff / 2;

/* The bit mask value corresponding to MALLOC_ALIGNMENT */
//manually inlined - const CHUNK_ALIGN_MASK: __size_t = 7;

/* True if address a has acceptable alignment */
function is_aligned(A: __ptr): boolean (A & (7 as __size_t)) == (0 as __size_t);

/* the number of bytes to offset an address to align it */
//#define align_offset(A) ((((size_t)(A) & CHUNK_ALIGN_MASK) == 0)? 0 : ((MALLOC_ALIGNMENT - ((size_t)(A) & CHUNK_ALIGN_MASK)) & CHUNK_ALIGN_MASK))
function align_offset(A: __ptr): __ptr if((A & (7 as __size_t)) == (0 as __size_t)) 0 as __ptr; else (((8 as __ptr) - (A & (7 as __size_t))) & (7 as __size_t));
function align_offset_size_t(A: __size_t): __size_t if((A & (7 as __size_t)) == (0 as __size_t)) 0 as __size_t; else (((8 as __size_t) - (A & (7 as __size_t))) & (7 as __size_t));

/* MORECORE and MMAP must return MFAIL on failure */
//#define MFAIL                ((void*)(MAX_SIZE_T))
//#define CMFAIL               ((char*)(MFAIL)) /* defined for convenience */

//#define CALL_MORECORE(S)    MORECORE_DEFAULT(S)

/* MMAP stuff, all stubbed out */
//#define USE_MMAP_BIT            (SIZE_T_ZERO)
//#define MMAP(s)                 MFAIL
//#define MUNMAP(a, s)            (-1)
//#define DIRECT_MMAP(s)          MFAIL
//#define CALL_DIRECT_MMAP(s)     DIRECT_MMAP(s)
//#define CALL_MMAP(s)            MMAP(s)
//#define CALL_MUNMAP(a, s)       MUNMAP((a), (s))
//#define CALL_MREMAP(addr, osz, nsz, mv)     MFAIL

/* mstate bit set if continguous morecore disabled or failed */
//#define USE_NONCONTIGUOUS_BIT (4U)

/* segment bit set in create_mspace_with_base */
//#define EXTERN_BIT            (8U)

/* LOCK stuff, all stubbed out */
//#define USE_LOCK_BIT               (0U)
//#define INITIAL_LOCK(l)            (0)
//#define DESTROY_LOCK(l)            (0)
//#define ACQUIRE_MALLOC_GLOBAL_LOCK()
//#define RELEASE_MALLOC_GLOBAL_LOCK()

/* -----------------------  Chunk representations ------------------------ */

/*
  (The following includes lightly edited explanations by Colin Plumb.)

  The malloc_chunk declaration below is misleading (but accurate and
  necessary).  It declares a "view" into memory allowing access to
  necessary fields at known offsets from a given base.

  Chunks of memory are maintained using a `boundary tag' method as
  originally described by Knuth.  (See the paper by Paul Wilson
  ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a survey of such
  techniques.)  Sizes of free chunks are stored both in the front of
  each chunk and at the end.  This makes consolidating fragmented
  chunks into bigger chunks fast.  The head fields also hold bits
  representing whether chunks are free or in use.

  Here are some pictures to make it clearer.  They are "exploded" to
  show that the state of a chunk can be thought of as extending from
  the high 31 bits of the head field of its header through the
  prev_foot and PINUSE_BIT bit of the following chunk header.

  A chunk that's in use looks like:

   chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           | Size of previous chunk (if P = 0)                             |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         1| +-+
   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               |
         +-                                                             -+
         |                                                               |
         +-                                                             -+
         |                                                               :
         +-      size - sizeof(size_t) available payload bytes          -+
         :                                                               |
 chunk-> +-                                                             -+
         |                                                               |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|
       | Size of next chunk (may or may not be in use)               | +-+
 mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    And if it's free, it looks like this:

   chunk-> +-                                                             -+
           | User payload (must be in use, or we would have merged!)       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         0| +-+
   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Next pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Prev pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               :
         +-      size - sizeof(struct chunk) unused bytes               -+
         :                                                               |
 chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Size of this chunk                                            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|
       | Size of next chunk (must be in use, or we would have merged)| +-+
 mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                                                               :
       +- User payload                                                -+
       :                                                               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                                                     |0|
                                                                     +-+
  Note that since we always merge adjacent free chunks, the chunks
  adjacent to a free chunk must be in use.

  Given a pointer to a chunk (which can be derived trivially from the
  payload pointer) we can, in O(1) time, find out whether the adjacent
  chunks are free, and if so, unlink them from the lists that they
  are on and merge them with the current chunk.

  Chunks always begin on even word boundaries, so the mem portion
  (which is returned to the user) is also on an even word boundary, and
  thus at least double-word aligned.

  The P (PINUSE_BIT) bit, stored in the unused low-order bit of the
  chunk size (which is always a multiple of two words), is an in-use
  bit for the *previous* chunk.  If that bit is *clear*, then the
  word before the current chunk size contains the previous chunk
  size, and can be used to find the front of the previous chunk.
  The very first chunk allocated always has this bit set, preventing
  access to non-existent (or non-owned) memory. If pinuse is set for
  any given chunk, then you CANNOT determine the size of the
  previous chunk, and might even get a memory addressing fault when
  trying to do so.

  The C (CINUSE_BIT) bit, stored in the unused second-lowest bit of
  the chunk size redundantly records whether the current chunk is
  inuse (unless the chunk is mmapped). This redundancy enables usage
  checks within free and realloc, and reduces indirection when freeing
  and consolidating chunks.

  Each freshly allocated chunk must have both cinuse and pinuse set.
  That is, each allocated chunk borders either a previously allocated
  and still in-use chunk, or the base of its memory arena. This is
  ensured by making all allocations from the `lowest' part of any
  found chunk.  Further, no free chunk physically borders another one,
  so each free chunk is known to be preceded and followed by either
  inuse chunks or the ends of memory.

  Note that the `foot' of the current chunk is actually represented
  as the prev_foot of the NEXT chunk. This makes it easier to
  deal with alignments etc but can be very confusing when trying
  to extend or adapt this code.

  The exceptions to all this are

     1. The special chunk `top' is the top-most available chunk (i.e.,
        the one bordering the end of available memory). It is treated
        specially.  Top is never included in any bin, is used only if
        no other chunk is available, and is released back to the
        system if it is very large (see M_TRIM_THRESHOLD).  In effect,
        the top chunk is treated as larger (and thus less well
        fitting) than any other available chunk.  The top chunk
        doesn't update its trailing size field since there is no next
        contiguous chunk that would have to index off it. However,
        space is still allocated for it (TOP_FOOT_SIZE) to enable
        separation or merging when space is extended.

     3. Chunks allocated via mmap, have both cinuse and pinuse bits
        cleared in their head fields.  Because they are allocated
        one-by-one, each must carry its own prev_foot field, which is
        also used to hold the offset this chunk has within its mmapped
        region, which is needed to preserve alignment. Each mmapped
        chunk is trailed by the first two fields of a fake next-chunk
        for sake of usage checks.

*/

__struct malloc_chunk {
  prev_foot: __size_t;  // Size of previous chunk (if free)
  head: __size_t;       // Size and inuse bits
  fd: __Option<malloc_chunk>;         // double links -- used only if free. was struct malloc_chunk*
  bk: __Option<malloc_chunk>;
}

/*
typedef struct malloc_chunk  mchunk;
typedef struct malloc_chunk* mchunkptr;
typedef struct malloc_chunk* sbinptr;  // The type of bins of chunks
typedef unsigned int bindex_t;         // using a __size_t because I don't have a u32
typedef unsigned int binmap_t;         // Described below 
typedef unsigned int flag_t;           // The type of various bit flag sets
*/

const MCHUNK_SIZE         = __sizeof(malloc_chunk);
//#define CHUNK_OVERHEAD      (SIZE_T_SIZE) = 4

/* The smallest size we can malloc is an aligned minimal chunk */
//#define MIN_CHUNK_SIZE ((MCHUNK_SIZE + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)
const MIN_CHUNK_SIZE: __size_t = ((MCHUNK_SIZE + (7 as __size_t)) & ~(7 as __size_t));

/* conversion from malloc headers to user pointers, and back */
//#define chunk2mem(p)        ((void*)((char*)(p)       + TWO_SIZE_T_SIZES))
function chunk2mem(p: malloc_chunk): __ptr (p as __ptr) + (8 as __size_t);
//#define mem2chunk(mem)      ((mchunkptr)((char*)(mem) - TWO_SIZE_T_SIZES))
function mem2chunk(mem: __ptr): malloc_chunk (mem - (8 as __size_t)) as malloc_chunk;

/* chunk associated with aligned address A */
//#define align_as_chunk(A)   (mchunkptr)((A) + align_offset(chunk2mem(A)))
function align_as_chunk(A: __ptr): malloc_chunk  (A + align_offset(A+(8 as __size_t))) as malloc_chunk;

/* Bounds on request (not chunk) sizes. */
/* WA1 - I kinda hard coded this based on what I know of JS. We will blow up before this anyway*/
const MAX_REQUEST  = (1024*1024*1024) as __size_t;
//#define MIN_REQUEST         (MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)
const MIN_REQUEST  = (MIN_CHUNK_SIZE - (5 as __size_t));

/* pad request bytes into a usable size */
//#define pad_request(req) (((req) + CHUNK_OVERHEAD + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)
function pad_request(req: __size_t): __size_t   ((req + (11 as __size_t)) & ~(7 as __size_t));

/* pad request, checking for minimum (but not maximum) */
function request2size(req: __size_t): __size_t if(req < MIN_REQUEST) MIN_CHUNK_SIZE; else pad_request(req);

/* ------------------ Operations on head and foot fields ----------------- */

/*
  The head field of a chunk is or'ed with PINUSE_BIT when previous
  adjacent chunk in use, and or'ed with CINUSE_BIT if this chunk is in
  use, unless mmapped, in which case both bits are cleared.

  FLAG4_BIT is not used by this malloc, but might be useful in extensions.
*/

//#define PINUSE_BIT          (SIZE_T_ONE) //1
//#define CINUSE_BIT          (SIZE_T_TWO) //2
//#define FLAG4_BIT           (SIZE_T_FOUR) //4
//#define INUSE_BITS          (PINUSE_BIT|CINUSE_BIT) //3
//#define FLAG_BITS           (PINUSE_BIT|CINUSE_BIT|FLAG4_BIT) //7

/* Head value for fenceposts */
//#define FENCEPOST_HEAD      (INUSE_BITS|SIZE_T_SIZE) //7

/* extraction of fields from head words */
/* WA1 - better get these guys inlined! */
//#define cinuse(p)           ((p)->head & CINUSE_BIT)
function cinuse(p: malloc_chunk): boolean           (p.head & (2 as __size_t)) != (0 as __size_t);
//#define pinuse(p)           ((p)->head & PINUSE_BIT)
function pinuse(p: malloc_chunk): boolean           (p.head & (1 as __size_t)) != (0 as __size_t);
//#define flag4inuse(p)       ((p)->head & FLAG4_BIT)
function flag4inuse(p: malloc_chunk): boolean       (p.head & (4 as __size_t)) != (0 as __size_t);
//#define is_inuse(p)         (((p)->head & INUSE_BITS) != PINUSE_BIT)
function is_inuse(p: malloc_chunk): boolean         (p.head & (3 as __size_t)) != (1 as __size_t);
//#define is_mmapped(p)       (((p)->head & INUSE_BITS) == 0)

//#define chunksize(p)        ((p)->head & ~(FLAG_BITS))
function chunksize(p: malloc_chunk): __size_t        (p.head & ~(7 as __size_t));

//#define clear_pinuse(p)     ((p)->head &= ~PINUSE_BIT)
function clear_pinuse(p: malloc_chunk): void     p.head &= ~(1 as __size_t);
//#define set_flag4(p)        ((p)->head |= FLAG4_BIT)
function set_flag4(p: malloc_chunk): void        p.head |= (4 as __size_t);
//#define clear_flag4(p)      ((p)->head &= ~FLAG4_BIT)
function clear_flag4(p: malloc_chunk): void      p.head &= ~(4 as __size_t);

/* Treat space at ptr +/- offset as a chunk */
/* WA1 - and this, children, is why our typesystem has a back door and an unsafe feature */
//#define chunk_plus_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))
function chunk_plus_offset(p: malloc_chunk, s: __size_t): malloc_chunk  ((p as __ptr) + s) as malloc_chunk;
//#define chunk_minus_offset(p, s) ((mchunkptr)(((char*)(p)) - (s)))
function chunk_minus_offset(p: malloc_chunk, s: __size_t): malloc_chunk ((p as __ptr) - s) as malloc_chunk;

/* Ptr to next or previous physical malloc_chunk. */
//#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~FLAG_BITS)))
function next_chunk(p: malloc_chunk): malloc_chunk ((p as __ptr) + (p.head & ~(7 as __size_t))) as malloc_chunk;
//#define prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)->prev_foot) ))
function prev_chunk(p: malloc_chunk): malloc_chunk ((p as __ptr) - p.prev_foot) as malloc_chunk;

/* extract next chunk's pinuse bit */
//#define next_pinuse(p)  ((next_chunk(p)->head) & PINUSE_BIT)
function next_pinuse(p: malloc_chunk): boolean (next_chunk(p).head & (1 as __size_t)) != (0 as __size_t);

/* Get/set size at footer */
//#define get_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot)
//#define set_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot = (s))
function set_foot(p: malloc_chunk, s: __size_t): void { 
    // you need a temporary because the '+' operator can't be used as an lhs. 
    let t = ((p as __ptr) + s) as malloc_chunk;
    t.prev_foot = s;
}

/* Set size, pinuse bit, and foot */
//#define set_size_and_pinuse_of_free_chunk(p, s)  ((p)->head = (s|PINUSE_BIT), set_foot(p, s))
function set_size_and_pinuse_of_free_chunk(p: malloc_chunk, s: __size_t): void {
    p.head = (s|(1 as __size_t));
    set_foot(p, s);
}

/* Set size, pinuse bit, foot, and clear next pinuse */
//#define set_free_with_pinuse(p, s, n)  (clear_pinuse(n), set_size_and_pinuse_of_free_chunk(p, s))
function set_free_with_pinuse(p: malloc_chunk, s: __size_t, n: malloc_chunk): void {
    clear_pinuse(n);
    set_size_and_pinuse_of_free_chunk(p, s);
}

/* Get the internal overhead associated with chunk p */
//#define overhead_for(p) (is_mmapped(p)? MMAP_CHUNK_OVERHEAD : CHUNK_OVERHEAD)
//function overhead_for(p: malloc_chunk): __size_t 4;

/* Return true if malloced space is not necessarily cleared */
//#define calloc_must_clear(p) (1)
//function calloc_must_clear(p: malloc_chunk): boolean true;

/* ---------------------- Overlaid data structures ----------------------- */

/*
  When chunks are not in use, they are treated as nodes of either
  lists or trees.

  "Small"  chunks are stored in circular doubly-linked lists, and look
  like this:

    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk                            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                         |P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  Larger chunks are kept in a form of bitwise digital trees (aka
  tries) keyed on chunksizes.  Because malloc_tree_chunks are only for
  free chunks greater than 256 bytes, their size doesn't impose any
  constraints on user chunk sizes.  Each node looks like:

    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk                            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                         |P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk of same size        |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk of same size       |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to left child (child[0])                  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to right child (child[1])                 |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to parent                                 |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             bin index of this chunk                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space                                      .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  Each tree holding treenodes is a tree of unique chunk sizes.  Chunks
  of the same size are arranged in a circularly-linked list, with only
  the oldest chunk (the next to be used, in our FIFO ordering)
  actually in the tree.  (Tree members are distinguished by a non-null
  parent pointer.)  If a chunk with the same size an an existing node
  is inserted, it is linked off the existing node using pointers that
  work in the same way as fd/bk pointers of small chunks.

  Each tree contains a power of 2 sized range of chunk sizes (the
  smallest is 0x100 <= x < 0x180), which is is divided in half at each
  tree level, with the chunks in the smaller half of the range (0x100
  <= x < 0x140 for the top nose) in the left subtree and the larger
  half (0x140 <= x < 0x180) in the right subtree.  This is, of course,
  done by inspecting individual bits.

  Using these rules, each node's left subtree contains all smaller
  sizes than its right subtree.  However, the node at the root of each
  subtree has no particular ordering relationship to either.  (The
  dividing line between the subtree sizes is based on trie relation.)
  If we remove the last chunk of a given size from the interior of the
  tree, we need to replace it with a leaf node.  The tree ordering
  rules permit a node to be replaced by any leaf below it.

  The smallest chunk in a tree (a common operation in a best-fit
  allocator) can be found by walking a path to the leftmost leaf in
  the tree.  Unlike a usual binary tree, where we follow left child
  pointers until we reach a null, here we follow the right child
  pointer any time the left one is null, until we reach a leaf with
  both child pointers null. The smallest chunk in the tree will be
  somewhere along that path.

  The worst case number of steps to add, find, or remove a node is
  bounded by the number of bits differentiating chunks within
  bins. Under current bin calculations, this ranges from 6 up to 21
  (for 32 bit sizes) or up to 53 (for 64 bit sizes). The typical case
  is of course much better.
*/

__struct malloc_tree_chunk {
  /* The first four fields must be compatible with malloc_chunk */
  prev_foot: __size_t;
  head: __size_t;
  fd: __Option<malloc_tree_chunk>;
  bk: __Option<malloc_tree_chunk>;

  //WA1 - in dlmalloc these are an array of size 2. I don't have an 
  //array implementation yet, and it doesn't seem that important
  child_0: __Option<malloc_tree_chunk>; 
  child_1: __Option<malloc_tree_chunk>;
  parent: __Option<malloc_tree_chunk>;
  index: __size_t; //actually should be a u32, but this will do
}

/* A little helper macro for trees */
//#define leftmost_child(t) ((t)->child[0] != 0? (t)->child[0] : (t)->child[1])
function leftmost_child(t: malloc_tree_chunk): __Option<malloc_tree_chunk> {
  if(t.child_0.isSome())
    t.child_0;
  else 
    t.child_1;
}

/* ----------------------------- Segments -------------------------------- */

/*
  Each malloc space may include non-contiguous segments, held in a
  list headed by an embedded malloc_segment record representing the
  top-most space. Segments also include flags holding properties of
  the space. Large chunks that are directly allocated by mmap are not
  included in this list. They are instead independently created and
  destroyed without otherwise keeping track of them.

  Segment management mainly comes into play for spaces allocated by
  MMAP.  Any call to MMAP might or might not return memory that is
  adjacent to an existing segment.  MORECORE normally contiguously
  extends the current space, so this space is almost always adjacent,
  which is simpler and faster to deal with. (This is why MORECORE is
  used preferentially to MMAP when both are available -- see
  sys_alloc.)  When allocating using MMAP, we don't use any of the
  hinting mechanisms (inconsistently) supported in various
  implementations of unix mmap, or distinguish reserving from
  committing memory. Instead, we just ask for space, and exploit
  contiguity when we get it.  It is probably possible to do
  better than this on some systems, but no general scheme seems
  to be significantly better.

  Management entails a simpler variant of the consolidation scheme
  used for chunks to reduce fragmentation -- new adjacent memory is
  normally prepended or appended to an existing segment. However,
  there are limitations compared to chunk consolidation that mostly
  reflect the fact that segment processing is relatively infrequent
  (occurring only when getting memory from system) and that we
  don't expect to have huge numbers of segments:

  * Segments are not indexed, so traversal requires linear scans.  (It
    would be possible to index these, but is not worth the extra
    overhead and complexity for most programs on most platforms.)
  * New segments are only appended to old ones when holding top-most
    memory; if they cannot be prepended to others, they are held in
    different segments.

  Except for the top-most segment of an mstate, each segment record
  is kept at the tail of its segment. Segments are added by pushing
  segment records onto the list headed by &mstate.seg for the
  containing mstate.

  Segment flags control allocation/merge/deallocation policies:
  * If EXTERN_BIT set, then we did not allocate this segment,
    and so should not try to deallocate or merge with others.
    (This currently holds only for the initial segment passed
    into create_mspace_with_base.)
  * If USE_MMAP_BIT set, the segment may be merged with
    other surrounding mmapped segments and trimmed/de-allocated
    using munmap.
  * If neither bit is set, then the segment was obtained using
    MORECORE so can be merged with surrounding MORECORE'd segments
    and deallocated/trimmed using MORECORE with negative arguments.
*/

__struct malloc_segment {
  base: __ptr;                    /* base address */
  size: __size_t;                 /* allocated size */
  next: __Option<malloc_segment>;   /* ptr to next segment */
  //sflags: __size_t;             /* mmap and extern flag WA1 - was a u32, but not used*/
}

//#define is_mmapped_segment(S)  ((S)->sflags & USE_MMAP_BIT) - false
//#define is_extern_segment(S)   ((S)->sflags & EXTERN_BIT) - false

/* ---------------------------- malloc_state ----------------------------- */

/*
   A malloc_state holds all of the bookkeeping for a space.
   The main fields are:

  Top
    The topmost chunk of the currently active segment. Its size is
    cached in topsize.  The actual size of topmost space is
    topsize+TOP_FOOT_SIZE, which includes space reserved for adding
    fenceposts and segment records if necessary when getting more
    space from the system.  The size at which to autotrim top is
    cached from mparams in trim_check, except that it is disabled if
    an autotrim fails.

  Designated victim (dv)
    This is the preferred chunk for servicing small requests that
    don't have exact fits.  It is normally the chunk split off most
    recently to service another small request.  Its size is cached in
    dvsize. The link fields of this chunk are not maintained since it
    is not kept in a bin.

  SmallBins
    An array of bin headers for free chunks.  These bins hold chunks
    with sizes less than MIN_LARGE_SIZE bytes. Each bin contains
    chunks of all the same size, spaced 8 bytes apart.  To simplify
    use in double-linked lists, each bin header acts as a malloc_chunk
    pointing to the real first node, if it exists (else pointing to
    itself).  This avoids special-casing for headers.  But to avoid
    waste, we allocate only the fd/bk pointers of bins, and then use
    repositioning tricks to treat these as the fields of a chunk.

  TreeBins
    Treebins are pointers to the roots of trees holding a range of
    sizes. There are 2 equally spaced treebins for each power of two
    from TREE_SHIFT to TREE_SHIFT+16. The last bin holds anything
    larger.

  Bin maps
    There is one bit map for small bins ("smallmap") and one for
    treebins ("treemap).  Each bin sets its bit when non-empty, and
    clears the bit when empty.  Bit operations are then used to avoid
    bin-by-bin searching -- nearly all "search" is done without ever
    looking at bins that won't be selected.  The bit maps
    conservatively use 32 bits per map word, even if on 64bit system.
    For a good description of some of the bit-based techniques used
    here, see Henry S. Warren Jr's book "Hacker's Delight" (and
    supplement at http://hackersdelight.org/). Many of these are
    intended to reduce the branchiness of paths through malloc etc, as
    well as to reduce the number of memory locations read or written.

  Segments
    A list of segments headed by an embedded malloc_segment record
    representing the initial space.

  Address check support
    The least_addr field is the least address ever obtained from
    MORECORE or MMAP. Attempted frees and reallocs of any address less
    than this are trapped (unless INSECURE is defined).

  Magic tag
    A cross-check field that should always hold same value as mparams.magic.

  Max allowed footprint
    The maximum allowed bytes to allocate from system (zero means no limit)

  Flags
    Bits recording whether to use MMAP, locks, or contiguous MORECORE

  Statistics
    Each space keeps track of current and maximum system memory
    obtained via MORECORE or MMAP.

  Trim support
    Fields holding the amount of unused topmost memory that should trigger
    trimming, and a counter to force periodic scanning to release unused
    non-topmost segments.

  Locking
    If USE_LOCKS is defined, the "mutex" lock is acquired and released
    around every public call using this mspace.

  Extension support
    A void* pointer and a size_t field that can be used to help implement
    extensions to this malloc.
*/

/* Bin types, widths and sizes */
//#define NSMALLBINS        (32U)
//#define NTREEBINS         (32U)
//#define SMALLBIN_SHIFT    (3U)
//#define SMALLBIN_WIDTH    (SIZE_T_ONE << SMALLBIN_SHIFT) => 8
//#define TREEBIN_SHIFT     (8U)
//#define MIN_LARGE_SIZE    (SIZE_T_ONE << TREEBIN_SHIFT) => 256
//#define MAX_SMALL_SIZE    (MIN_LARGE_SIZE - SIZE_T_ONE) => 255
//#define MAX_SMALL_REQUEST (MAX_SMALL_SIZE - CHUNK_ALIGN_MASK - CHUNK_OVERHEAD) => 256 - 7 - 4 => 245

__struct malloc_state {
  smallmap:         __size_t; //was a u32
  treemap:          __size_t; //was a u32
  dvsize:           __size_t;
  topsize:          __size_t;
  least_addr:       __ptr; //was a char*
  dv:               __Option<malloc_chunk>;
  top:              __Option<malloc_chunk>;
  trim_check:       __size_t;
  release_checks:   __size_t;
  magic:            __size_t;
  smallbins:        __array<__Option<malloc_chunk>>; //mchunkptr  smallbins[(NSMALLBINS+1)*2];
  treebins:         __array<__Option<malloc_tree_chunk>>; //tbinptr    treebins[NTREEBINS];
  footprint:        __size_t;
  max_footprint:    __size_t;
  footprint_limit:  __size_t; /* zero means no limit */
  mflags:           __size_t; //was a u32
  seg:              __Option<malloc_segment>;
  extp:             __ptr;      /* Unused but available for extensions */
  exts:             __size_t;
}


/* ------------- Global malloc_state and malloc_params ------------------- */

/*
  malloc_params holds global properties, including those that can be
  dynamically set using mallopt. There is a single instance, mparams,
  initialized in init_mparams. Note that the non-zeroness of "magic"
  also serves as an initialization flag.
*/

__struct malloc_params {
  magic:          __size_t;
  page_size:      __size_t;
  granularity:    __size_t;
  mmap_threshold: __size_t;
  trim_threshold: __size_t;
  default_mflags: __size_t; // was a flag_t aka u32;
}

const mparams: malloc_params = __static malloc_params {
  magic: 0 as __size_t, 
  page_size: 0 as __size_t, 
  granularity: 0 as __size_t, 
  mmap_threshold: 0 as __size_t, 
  trim_threshold: 0 as __size_t, 
  default_mflags: 0 as __size_t
};

/* Ensure mparams initialized */
//function ensure_initialization(): void { (mparams.magic != (0 as __size_t)) || init_mparams(); }

/* The global malloc_state used for all non-"mspace" calls */
const gm: malloc_state = __static malloc_state{
  smallmap:         (0 as __size_t),
  treemap:          (0 as __size_t),
  dvsize:           (0 as __size_t),
  topsize:          (0 as __size_t),
  least_addr:       (0 as __ptr),
  dv:               __null,
  top:              __null,
  trim_check:       (0 as __size_t),
  release_checks:   (0 as __size_t),
  magic:            (0 as __size_t),
  //66 lots of malloc_chunk...
  smallbins:        __static __array<__Option<malloc_chunk>> [
    __null, __null, __null, __null, __null, __null, __null, __null, __null, __null, 
    __null, __null, __null, __null, __null, __null, __null, __null, __null, __null, 
    __null, __null, __null, __null, __null, __null, __null, __null, __null, __null, 
    __null, __null, __null, __null, __null, __null, __null, __null, __null, __null, 
    __null, __null, __null, __null, __null, __null, __null, __null, __null, __null, 
    __null, __null, __null, __null, __null, __null, __null, __null, __null, __null, 
    __null, __null, __null, __null, __null, __null
  ],
  treebins:         __static __array<__Option<malloc_tree_chunk>>[
      __null, __null, __null, __null, __null, __null, __null, __null, __null, __null, 
      __null, __null, __null, __null, __null, __null, __null, __null, __null, __null, 
      __null, __null, __null, __null, __null, __null, __null, __null, __null, __null, 
      __null, __null
  ],
  footprint:        (0 as __size_t),
  max_footprint:    (0 as __size_t),
  footprint_limit:  (0 as __size_t),
  mflags:           (0 as __size_t),
  seg:              __null,
  extp:             (0 as __ptr),
  exts:             (0 as __size_t),
};
//#define is_global(M)       ((M) == &_gm_)

function is_initialized(m: malloc_state): boolean m.top != __null;

/* page-align a size */
//#define page_align(S) (((S) + (mparams.page_size - SIZE_T_ONE)) & ~(mparams.page_size - SIZE_T_ONE))
function page_align(s: __size_t): __size_t ((s + (mparams.page_size - (1 as __size_t))) & ~(mparams.page_size - (1 as __size_t)));

/* granularity-align a size */
//#define granularity_align(S)  (((S) + (mparams.granularity - SIZE_T_ONE)) & ~(mparams.granularity - SIZE_T_ONE))
function granularity_align(s: __size_t): __size_t ((s + (mparams.granularity - (1 as __size_t))) & ~(mparams.granularity - (1 as __size_t)));

/*
  TOP_FOOT_SIZE is padding at the end of a segment, including space
  that may be needed to place segment records and fenceposts when new
  noncontiguous segments are added.
*/
//#define TOP_FOOT_SIZE (align_offset(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE);
const TOP_FOOT_SIZE = align_offset_size_t(8 as __size_t) + pad_request(__sizeof(malloc_segment)) + MIN_CHUNK_SIZE;

/* For sys_alloc, enough padding to ensure can malloc request on success */
//#define SYS_ALLOC_PADDING (TOP_FOOT_SIZE + MALLOC_ALIGNMENT)
const SYS_ALLOC_PADDING = TOP_FOOT_SIZE + (8 as __size_t);

//#define is_page_aligned(S) (((size_t)(S) & (mparams.page_size - SIZE_T_ONE)) == 0)
function is_page_aligned(s: __ptr): boolean ((s as __size_t) & (mparams.page_size - (1 as __size_t))) == (0 as __size_t);
//#define is_granularity_aligned(S) (((size_t)(S) & (mparams.granularity - SIZE_T_ONE)) == 0)
function is_granularity_aligned(s: __ptr): boolean ((s as __size_t) & (mparams.granularity - (1 as __size_t))) == (0 as __size_t);

/*  True if segment S holds address A */
//#define segment_holds(S, A) ((char*)(A) >= S->base && (char*)(A) < S->base + S->size)
//function segment_holds(s: malloc_segment, a: __ptr): boolean (a >= s.base && a < s.base + s.size);

/* Return segment holding given address */
/*
function segment_holding(m: malloc_state, addr: __ptr): __Option<malloc_segment> {
  let o_sp: __Option<malloc_segment> = m.seg;
  while(true) {
    let sp = option.__Option_unwrap<malloc_segment>(o_sp);
    if (addr >= sp.base && addr < sp.base + sp.size)
      return __Some(sp);
    o_sp = sp.next;
    if (o_sp == __null)
      return __null;
  }
  return __null;
}
*/

/* Return true if segment contains a segment link */
/*
function has_segment_link(m: malloc_state, ss: malloc_segment): boolean {
  let o_sp: __Option<malloc_segment> = m.seg;
  while(true) {
    let sp = option.__Option_unwrap<malloc_segment>(o_sp);
    if ((sp as __ptr) >= ss.base && (sp as __ptr) < ss.base + ss.size)
      return true;
    if (sp != sp.next) 
      return false;
  }
}
*/

//#define should_trim(M,s)  (0)

/*
  TOP_FOOT_SIZE is padding at the end of a segment, including space
  that may be needed to place segment records and fenceposts when new
  noncontiguous segments are added.
*/
//#define TOP_FOOT_SIZE  (align_offset(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE)
const TOP_FOOT_SIZE = align_offset(8 as __ptr)+pad_request(__sizeof(malloc_segment))+MIN_CHUNK_SIZE;

/* -------------------------------  Hooks -------------------------------- */

/*
  PREACTION should be defined to return 0 on success, and nonzero on
  failure. If you are not using locking, you can redefine these to do
  anything you like.
*/
//#define PREACTION(M) (0)
//#define POSTACTION(M)

/*
  CORRUPTION_ERROR_ACTION is triggered upon detected bad addresses.
  USAGE_ERROR_ACTION is triggered on detected bad frees and
  reallocs. The argument p is an address that might have triggered the
  fault. It is ignored by the two predefined actions, but might be
  useful in custom actions that try to help diagnose errors.
*/

//#define CORRUPTION_ERROR_ACTION(m) ABORT
//#define USAGE_ERROR_ACTION(m,p) ABORT

/* -------------------------- Debugging setup ---------------------------- */

//#define check_free_chunk(M,P)
//#define check_inuse_chunk(M,P)
//#define check_malloced_chunk(M,P,N)
//#define check_mmapped_chunk(M,P)
//#define check_malloc_state(M)
//#define check_top_chunk(M,P)

/* ---------------------------- Indexing Bins ---------------------------- */
//#define is_small(s)         (((s) >> SMALLBIN_SHIFT) < NSMALLBINS)
function is_small(s: __size_t): boolean s.shiftRight(3) < (32 as __size_t);

//#define small_index(s)      (bindex_t)((s)  >> SMALLBIN_SHIFT)
function small_index(s: __size_t): __size_t s.shiftRight(3);

//#define small_index2size(i) ((i)  << SMALLBIN_SHIFT)
function small_index2size(i: __size_t): __size_t i.shiftLeft(3);

//#define MIN_SMALL_INDEX     (small_index(MIN_CHUNK_SIZE))
const MIN_SMALL_INDEX = small_index(MIN_CHUNK_SIZE);

/* addressing by index. See above about smallbin repositioning */
//#define smallbin_at(M, i)   ((sbinptr)((char*)&((M)->smallbins[(i)<<1])))
function smallbin_at(m: malloc_state, i: __size_t): __Option<malloc_chunk> m.smallbins[i.shiftLeft(1) as int];

//#define treebin_at(M,i)     (&((M)->treebins[i]))
function treebin_at(m: malloc_state, i: __size_t): __Option<malloc_tree_chunk>  m.treebins[i as int];

//#define compute_tree_index(S, I)\
function compute_tree_index(s: __size_t) : __size_t {
  const x: __size_t = s.shiftRight(8);
  if (x == (0 as __size_t))
    0 as __size_t;
  else if (x > (0xFFFF as __size_t))
    31 as __size_t;
  else {
    const k: int = 31 - (x.countLeadingZeros() as int);
    (k.shiftLeft(1) as __size_t) + (s.shiftRight(k + 7) & (1 as __size_t));
  }
}

/* Shift placing maximum resolved bit in a treebin at i as sign bit */
//#define leftshift_for_tree_index(i) ((i == NTREEBINS-1)? 0 : ((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i) >> 1) + TREEBIN_SHIFT - 2)))
function leftshift_for_tree_index(i: __size_t): int {
  if (i == (31 as __size_t)) 0; else 31 - ((i.shiftRight(1) as int) + 6);
}

/* The size of the smallest chunk held in bin with index i */
//#define minsize_for_tree_index(i) (SIZE_T_ONE << (((i) >> 1) + TREEBIN_SHIFT)) | (((size_t)((i) & SIZE_T_ONE)) << (((i) >> 1) + TREEBIN_SHIFT - 1))

/* ------------------------ Operations on bin maps ----------------------- */

/* bit corresponding to given index */
//#define idx2bit(i)              ((binmap_t)(1) << (i))
function idx2bit(i: __size_t): __size_t (1 as __size_t).shiftLeft(i as int);

/* Mark/Clear bits with given index */
//#define mark_smallmap(M,i)      ((M)->smallmap |=  idx2bit(i))
//#define clear_smallmap(M,i)     ((M)->smallmap &= ~idx2bit(i))
//#define smallmap_is_marked(M,i) ((M)->smallmap &   idx2bit(i))

//#define mark_treemap(M,i)       ((M)->treemap  |=  idx2bit(i))
//#define clear_treemap(M,i)      ((M)->treemap  &= ~idx2bit(i))
//#define treemap_is_marked(M,i)  ((M)->treemap  &   idx2bit(i))

/* isolate the least set bit of a bitmap */
//#define least_bit(x)         ((x) & -(x))

